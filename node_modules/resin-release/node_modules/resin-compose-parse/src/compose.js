"use strict";
exports.__esModule = true;
var _ = require("lodash");
var path = require("path");
var errors_1 = require("./errors");
var schemas_1 = require("./schemas");
var packageJson = require('../package.json');
var packageVersion = packageJson.version;
function defaultComposition(image) {
    var context;
    if (image) {
        context = "image: " + image;
    }
    else {
        context = 'build: "."';
    }
    return "# Auto-generated compose file by resin-compose-parse@v" + packageVersion + "\nversion: '2.1'\nnetworks: {}\nvolumes:\n  resin-data: {}\nservices:\n  main:\n    " + context + "\n    privileged: true\n    restart: always\n    network_mode: host\n    volumes:\n      - resin-data:/data\n    labels:\n      io.resin.features.kernel-modules: 1\n      io.resin.features.firmware: 1\n      io.resin.features.dbus: 1\n      io.resin.features.supervisor-api: 1\n      io.resin.features.resin-api: 1\n";
}
exports.defaultComposition = defaultComposition;
function normalize(c) {
    if (!_.isObject(c)) {
        throw new errors_1.ValidationError('Invalid composition format');
    }
    var version;
    if (_.isUndefined(c.version)) {
        version = schemas_1.SchemaVersion.v1_0;
    }
    else {
        if (!_.isString(c.version)) {
            c.version = "" + c.version;
        }
        switch (c.version) {
            case '2':
            case '2.0':
                version = schemas_1.SchemaVersion.v2_0;
                break;
            case '2.1':
                version = schemas_1.SchemaVersion.v2_1;
                break;
            default:
                throw new errors_1.ValidationError('Unsupported composition version');
        }
    }
    try {
        schemas_1.validate(version, c);
    }
    catch (e) {
        if (e instanceof schemas_1.SchemaError) {
            throw new errors_1.ValidationError(e);
        }
        throw e;
    }
    var _loop_1 = function () {
        switch (version) {
            case schemas_1.SchemaVersion.v1_0:
                version = schemas_1.SchemaVersion.v2_0;
                c = { version: version, services: c };
                break;
            case schemas_1.SchemaVersion.v2_0:
                version = schemas_1.SchemaVersion.v2_1;
                c.version = version;
                break;
            case schemas_1.SchemaVersion.v2_1:
                if (c.volumes) {
                    var volumes = c.volumes;
                    c.volumes = _.mapValues(volumes, normalizeVolume);
                }
                var services = c.services || {};
                var serviceNames_1 = _.keys(services);
                var volumeNames_1 = _.keys(c.volumes);
                c.services = _.mapValues(services, function (service) {
                    return normalizeService(service, serviceNames_1, volumeNames_1);
                });
                if (c.networks) {
                    var networks = c.networks;
                    c.networks = _.mapValues(networks, normalizeNetwork);
                }
                return { value: c };
        }
    };
    while (true) {
        var state_1 = _loop_1();
        if (typeof state_1 === "object")
            return state_1.value;
    }
}
exports.normalize = normalize;
function normalizeService(service, serviceNames, volumeNames) {
    if (!service.image && !service.build) {
        throw new errors_1.ValidationError('You must specify either an image or a build');
    }
    if (service.build) {
        if (_.isString(service.build)) {
            service.build = { context: service.build };
        }
        if (service.build.args) {
            service.build.args = normalizeKeyValuePairs(service.build.args);
        }
        if (service.build.labels) {
            service.build.labels = normalizeKeyValuePairs(service.build.labels);
            validateLabels(service.build.labels);
        }
    }
    if (service.depends_on) {
        if (!_.isArray(service.depends_on)) {
            throw new errors_1.ValidationError('Service dependencies must be an array');
        }
        if (_.uniq(service.depends_on).length !== service.depends_on.length) {
            throw new errors_1.ValidationError('Service dependencies must be unique');
        }
        service.depends_on.forEach(function (dep) {
            if (!_.includes(serviceNames, dep)) {
                throw new errors_1.ValidationError("Unknown service dependency: " + dep);
            }
        });
    }
    if (service.environment) {
        service.environment = normalizeKeyValuePairs(service.environment);
    }
    if (service.extra_hosts) {
        if (_.isObject(service.extra_hosts)) {
            service.extra_hosts = normalizeExtraHostObject(service.extra_hosts);
        }
    }
    if (service.labels) {
        service.labels = normalizeKeyValuePairs(service.labels);
        validateLabels(service.labels);
    }
    if (service.ports) {
        service.ports = normalizeArrayOfStrings(service.ports);
    }
    if (service.volumes) {
        service.volumes.forEach(function (volume) {
            validateServiceVolume(volume, volumeNames);
        });
    }
    return service;
}
function normalizeArrayOfStrings(value) {
    return _.map(value, String);
}
function validateServiceVolume(serviceVolume, volumeNames) {
    var colonIndex = serviceVolume.indexOf(':');
    if (colonIndex === -1) {
        throw new errors_1.ValidationError("Invalid volume: '" + serviceVolume + "'");
    }
    var source = serviceVolume.slice(0, colonIndex);
    if (path.parse(source).dir !== '') {
        throw new errors_1.ValidationError('Bind mounts are not allowed');
    }
    if (volumeNames.indexOf(source) === -1) {
        throw new errors_1.ValidationError("Missing volume definition for '" + source + "'");
    }
}
function validateLabels(labels) {
    _.keys(labels).forEach(function (name) {
        if (!/^[a-zA-Z0-9.-]+$/.test(name)) {
            throw new errors_1.ValidationError("Invalid label name: \"" + name + "\". " +
                'Label names must only contain alphanumeric ' +
                'characters, periods "." and dashes "-".');
        }
    });
}
function normalizeNetwork(network) {
    if (!network) {
        return null;
    }
    if (network.labels) {
        network.labels = normalizeKeyValuePairs(network.labels);
        validateLabels(network.labels);
    }
    return network;
}
function normalizeVolume(volume) {
    if (!volume) {
        return null;
    }
    if (volume.labels) {
        volume.labels = normalizeKeyValuePairs(volume.labels);
        validateLabels(volume.labels);
    }
    return volume;
}
function normalizeExtraHostObject(extraHostsObject) {
    return _.map(extraHostsObject, function (host, ip) { return host + ":" + ip; });
}
function parse(c) {
    if (c.version !== schemas_1.DEFAULT_SCHEMA_VERSION) {
        throw new Error('Unsupported composition version');
    }
    return _.toPairs(c.services).map(function (_a) {
        var name = _a[0], service = _a[1];
        return createImageDescriptor(name, service);
    });
}
exports.parse = parse;
function createImageDescriptor(serviceName, service) {
    if (service.image && !service.build) {
        return { serviceName: serviceName, image: service.image };
    }
    if (!service.build) {
        throw new errors_1.InternalInconsistencyError();
    }
    var build = {
        context: service.build.context
    };
    if (service.build.dockerfile) {
        build.dockerfile = service.build.dockerfile;
    }
    if (service.build.args) {
        build.args = service.build.args;
    }
    if (service.build.labels) {
        build.labels = service.build.labels;
    }
    if (service.image) {
        build.tag = service.image;
    }
    return { serviceName: serviceName, image: build };
}
function normalizeKeyValuePairs(obj, sep) {
    if (sep === void 0) { sep = '='; }
    if (!obj) {
        return {};
    }
    if (!_.isArray(obj)) {
        return _(obj)
            .toPairs()
            .map(function (_a) {
            var key = _a[0], value = _a[1];
            return [key, value ? ('' + value).trim() : ''];
        })
            .fromPairs()
            .value();
    }
    return _(obj)
        .map(function (val) {
        var parts = val.split(sep);
        return [parts.shift(), parts.join('=')];
    })
        .map(function (_a) {
        var key = _a[0], value = _a[1];
        return [key.trim(), value ? value.trim() : ''];
    })
        .fromPairs()
        .value();
}
//# sourceMappingURL=compose.js.map