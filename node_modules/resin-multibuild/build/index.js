"use strict";
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
const Promise = require("bluebird");
const _ = require("lodash");
const Compose = require("resin-compose-parse");
const tar = require("tar-stream");
const TarUtils = require("tar-utils");
const build_1 = require("./build");
const errors_1 = require("./errors");
const PathUtils = require("./path-utils");
exports.PathUtils = PathUtils;
const resolve_1 = require("./resolve");
const Utils = require("./utils");
__export(require("./errors"));
__export(require("./local-image"));
__export(require("./registry-secrets"));
function splitBuildStream(composition, buildStream) {
    const images = Compose.parse(composition);
    return fromImageDescriptors(images, buildStream);
}
exports.splitBuildStream = splitBuildStream;
function fromImageDescriptors(images, buildStream) {
    return new Promise((resolve, reject) => {
        const tasks = Utils.generateBuildTasks(images);
        const extract = tar.extract();
        const entryFn = (header, stream, next) => {
            const matchingTasks = _.filter(tasks, (task) => {
                if (task.external) {
                    return false;
                }
                return PathUtils.contains(task.context, header.name);
            });
            if (matchingTasks.length > 0) {
                TarUtils.streamToBuffer(stream)
                    .then((buf) => {
                    matchingTasks.forEach((task) => {
                        const newHeader = _.cloneDeep(header);
                        newHeader.name = PathUtils.relative(task.context, header.name);
                        task.buildStream.entry(newHeader, buf);
                    });
                })
                    .then(() => {
                    next();
                    return null;
                })
                    .catch((e) => reject(new errors_1.TarError(e)));
            }
            else {
                Utils.drainStream(stream)
                    .then(() => {
                    next();
                    return null;
                })
                    .catch((e) => reject(new errors_1.TarError(e)));
            }
        };
        extract.on('entry', entryFn);
        extract.on('finish', () => {
            _.each(tasks, (task) => {
                if (!task.external) {
                    task.buildStream.finalize();
                }
            });
            resolve(tasks);
        });
        extract.on('error', (e) => {
            reject(new errors_1.TarError(e));
        });
        buildStream.pipe(extract);
    });
}
exports.fromImageDescriptors = fromImageDescriptors;
function performResolution(tasks, architecture, deviceType) {
    return Promise.map(tasks, (task) => {
        return resolve_1.resolveTask(task, architecture, deviceType);
    });
}
exports.performResolution = performResolution;
function performBuilds(tasks, docker) {
    return Promise.map(tasks, (task) => {
        return performSingleBuild(task, docker);
    });
}
exports.performBuilds = performBuilds;
function performSingleBuild(task, docker) {
    return build_1.runBuildTask(task, docker)
        .catch((e) => {
        throw new errors_1.BuildProcessError(e);
    });
}
exports.performSingleBuild = performSingleBuild;
//# sourceMappingURL=index.js.map