// Generated by CoffeeScript 1.12.5
var assign, cloneDeep, convertExpandToObject, dateToMoment, errors, getRev, getSingleInstallSummary, groupBy, includes, isArray, isEmpty, isFunction, isNumber, isString, mapKeys, mapValues, memoizee, mergeExpandOptions, moment, notImplemented, now, omit, safeSemver, semver, throttle,
  hasProp = {}.hasOwnProperty;

errors = require('balena-errors');

semver = require('semver');

assign = require('lodash/assign');

cloneDeep = require('lodash/cloneDeep');

groupBy = require('lodash/groupBy');

includes = require('lodash/includes');

isArray = require('lodash/isArray');

isEmpty = require('lodash/isEmpty');

isFunction = require('lodash/isFunction');

isNumber = require('lodash/isNumber');

isString = require('lodash/isString');

mapKeys = require('lodash/mapKeys');

mapValues = require('lodash/mapValues');

omit = require('lodash/omit');

throttle = require('lodash/throttle');

memoizee = require('memoizee');

moment = require('moment');

exports.globalEnv = typeof window !== 'undefined' ? window : typeof self !== 'undefined' ? self : typeof global !== 'undefined' ? global : null;

exports.deviceTypes = require('./device-types');

exports.getImgMakerHelper = require('./img-maker');

exports.notImplemented = notImplemented = function() {
  throw new Error('The method is not implemented.');
};

exports.onlyIf = function(condition) {
  return function(fn) {
    if (condition) {
      return fn;
    } else {
      return notImplemented;
    }
  };
};

exports.now = now = throttle(function() {
  return moment();
}, 1000, {
  leading: true
});

exports.dateToMoment = dateToMoment = memoizee(function(date) {
  return moment(date);
}, {
  max: 1000,
  primitive: true
});

exports.timeSince = function(input, suffix) {
  var date, time;
  if (suffix == null) {
    suffix = true;
  }
  date = dateToMoment(input);
  time = now();
  return moment.min(time, date).from(time, !suffix);
};

exports.isId = isNumber;

exports.LOCKED_STATUS_CODE = 423;

exports.findCallback = function(args) {
  var lastArg;
  lastArg = args[args.length - 1];
  if (isFunction(lastArg)) {
    return lastArg;
  }
  return null;
};

exports.unauthorizedError = {
  code: 'BalenaRequestError',
  statusCode: 401
};

exports.notFoundResponse = {
  code: 'BalenaRequestError',
  statusCode: 404
};

exports.noDeviceForKeyResponse = {
  code: 'BalenaRequestError',
  statusCode: 500,
  body: 'No device found to associate with the api key'
};

exports.noApplicationForKeyResponse = {
  code: 'BalenaRequestError',
  statusCode: 500,
  body: 'No application found to associate with the api key'
};

exports.uniqueKeyViolated = {
  code: 'BalenaRequestError',
  body: 'Unique key constraint violated'
};

exports.treatAsMissingApplication = function(nameOrId) {
  return function(err) {
    var replacementErr;
    replacementErr = new errors.BalenaApplicationNotFound(nameOrId);
    replacementErr.stack = err.stack;
    throw replacementErr;
  };
};

exports.treatAsMissingDevice = function(uuidOrId) {
  return function(err) {
    var replacementErr;
    replacementErr = new errors.BalenaDeviceNotFound(uuidOrId);
    replacementErr.stack = err.stack;
    throw replacementErr;
  };
};

safeSemver = function(version) {
  return version.replace(/(\.[0-9]+)\.rev/, '$1+rev');
};

exports.osVersionRCompare = function(versionA, versionB) {
  var devA, devB, revA, revB, semverResult;
  versionA = safeSemver(versionA);
  versionB = safeSemver(versionB);
  semverResult = semver.rcompare(versionA, versionB);
  if (semverResult !== 0) {
    return semverResult;
  }
  revA = getRev(versionA);
  revB = getRev(versionB);
  if (revA !== revB) {
    return revB - revA;
  }
  devA = exports.isDevelopmentVersion(versionA);
  devB = exports.isDevelopmentVersion(versionB);
  if (devA !== devB) {
    return devA - devB;
  }
  return versionA.localeCompare(versionB);
};

exports.isDevelopmentVersion = function(version) {
  return /(\.|\+|-)dev/.test(version);
};

exports.isProvisioned = function(device) {
  return !isEmpty(device.supervisor_version) && !isEmpty(device.last_connectivity_event);
};

getRev = function(osVersion) {
  var rev;
  rev = semver.parse(osVersion).build.map(function(metadataPart) {
    var ref;
    return (ref = /rev(\d+)/.exec(metadataPart)) != null ? ref[1] : void 0;
  }).filter(function(x) {
    return x != null;
  })[0];
  if (rev != null) {
    return parseInt(rev, 10);
  } else {
    return 0;
  }
};

exports.mergePineOptions = function(defaults, extras) {
  var option, result, value;
  if (!extras) {
    return defaults;
  }
  result = cloneDeep(defaults);
  for (option in extras) {
    if (!hasProp.call(extras, option)) continue;
    value = extras[option];
    switch (option) {
      case '$select':
        if (value != null) {
          if (!isArray(value)) {
            value = [value];
          }
        }
        result[option] = value;
        break;
      case '$orderby':
      case '$top':
      case '$skip':
        result[option] = value;
        break;
      case '$filter':
        if (defaults.$filter) {
          result.$filter = {
            $and: [defaults.$filter, value]
          };
        } else {
          result.$filter = value;
        }
        break;
      case '$expand':
        result.$expand = mergeExpandOptions(defaults.$expand, value);
        break;
      default:
        throw new Error("Unknown pine option: " + option);
    }
  }
  return result;
};

mergeExpandOptions = function(defaultExpand, extraExpand) {
  var expandKey, expandOptions, extraExpandOptions;
  if (defaultExpand == null) {
    return extraExpand;
  }
  defaultExpand = convertExpandToObject(defaultExpand);
  extraExpand = convertExpandToObject(extraExpand);
  for (expandKey in extraExpand) {
    if (!hasProp.call(extraExpand, expandKey)) continue;
    extraExpandOptions = extraExpand[expandKey];
    expandOptions = defaultExpand[expandKey] || (defaultExpand[expandKey] = {});
    if (extraExpandOptions.$select) {
      expandOptions.$select = extraExpandOptions.$select;
    }
    if (extraExpandOptions.$filter) {
      if (expandOptions.$filter) {
        expandOptions.$filter = {
          $and: [expandOptions.$filter, extraExpandOptions.$filter]
        };
      } else {
        expandOptions.$filter = extraExpandOptions.$filter;
      }
    }
    if (extraExpandOptions.$expand) {
      expandOptions.$expand = mergeExpandOptions(expandOptions.$expand, extraExpandOptions.$expand);
    }
  }
  return defaultExpand;
};

convertExpandToObject = function(expandOption) {
  var expandKey, expandRelationshipOptions, invalidKeys, obj;
  if (expandOption == null) {
    return {};
  } else if (isString(expandOption)) {
    return (
      obj = {},
      obj["" + expandOption] = {},
      obj
    );
  } else if (isArray(expandOption)) {
    return expandOption.reduce(function(result, option) {
      var obj1;
      return assign(result, isString(option) ? (
        obj1 = {},
        obj1["" + option] = {},
        obj1
      ) : option);
    }, {});
  } else {
    for (expandKey in expandOption) {
      if (!hasProp.call(expandOption, expandKey)) continue;
      expandRelationshipOptions = expandOption[expandKey];
      invalidKeys = Object.keys(expandRelationshipOptions).filter(function(key) {
        return key !== '$select' && key !== '$expand' && key !== '$filter';
      });
      if (invalidKeys.length > 0) {
        throw new Error("Unknown pine expand options: " + invalidKeys);
      }
    }
    return cloneDeep(expandOption);
  }
};

exports.getCurrentServiceDetailsPineOptions = function() {
  return {
    $expand: {
      image_install: {
        $select: ['id', 'download_progress', 'status', 'install_date'],
        $filter: {
          $ne: [
            {
              $tolower: {
                $: 'status'
              }
            }, 'deleted'
          ]
        },
        $expand: {
          image: {
            $select: ['id'],
            $expand: {
              is_a_build_of__service: {
                $select: ['id', 'service_name']
              }
            }
          },
          is_provided_by__release: {
            $select: ['id', 'commit']
          }
        }
      },
      gateway_download: {
        $select: ['id', 'download_progress', 'status'],
        $filter: {
          $ne: [
            {
              $tolower: {
                $: 'status'
              }
            }, 'deleted'
          ]
        },
        $expand: {
          image: {
            $select: ['id'],
            $expand: {
              is_a_build_of__service: {
                $select: ['id', 'service_name']
              }
            }
          }
        }
      }
    }
  };
};

getSingleInstallSummary = function(rawData) {
  var image, ref, release, service;
  image = rawData.image[0];
  service = image.is_a_build_of__service[0];
  release = (ref = rawData.is_provided_by__release) != null ? ref[0] : void 0;
  return Object.assign({}, omit(rawData, ['image', 'is_provided_by__release']), {
    service_name: service.service_name,
    image_id: image.id,
    service_id: service.id,
    commit: release != null ? release.commit : void 0
  });
};

exports.generateCurrentServiceDetails = function(rawData) {
  var device, downloads, installs;
  installs = rawData.image_install.map(getSingleInstallSummary);
  downloads = rawData.gateway_download.map(getSingleInstallSummary);
  device = omit(rawData, ['image_install', 'gateway_download']);
  device.current_services = mapValues(groupBy(installs, 'service_name'), function(service_containers) {
    return service_containers.map(function(container) {
      return omit(container, 'service_name');
    }).sort(function(a, b) {
      return b.install_date.localeCompare(a.install_date);
    });
  });
  device.current_gateway_downloads = downloads;
  return device;
};
