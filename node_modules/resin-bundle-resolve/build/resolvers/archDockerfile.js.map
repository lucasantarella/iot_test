{"version":3,"sources":["../src/resolvers/archDockerfile.ts"],"names":[],"mappings":";;AAAA,oCAAoC;AACpC,6BAA6B;AAE7B,0DAA0D;AAS1D;IAAA;QACQ,aAAQ,GAAG,CAAC,CAAC;QACb,SAAI,GAAG,gCAAgC,CAAC;QAEvC,oBAAe,GAA6B,EAAE,CAAC;IA6DxD,CAAC;IAzDO,KAAK,CAAC,IAAc;QAC1B,IAAI,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,EAAE,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC,KAAK,YAAY,EAAE;YAKjE,MAAM,GAAG,GAAG,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC;YAC9C,IAAI,GAAG,KAAK,UAAU,EAAE;gBACvB,IAAI,CAAC,eAAe,CAAC,IAAI,CAAC,CAAC,GAAG,EAAE,IAAI,CAAC,CAAC,CAAC;aACvC;SACD;IACF,CAAC;IAEM,WAAW,CAAC,MAAc;QAEhC,IAAI,CAAC,eAAe,CAAC,GAAG,CAAC,UAAU,CAAC,EAAE;YACrC,IAAI,UAAU,CAAC,CAAC,CAAC,KAAK,MAAM,CAAC,YAAY,EAAE;gBAC1C,IAAI,CAAC,cAAc,GAAG,UAAU,CAAC;aACjC;iBAAM,IAAI,UAAU,CAAC,CAAC,CAAC,KAAK,MAAM,CAAC,UAAU,EAAE;gBAC/C,IAAI,CAAC,mBAAmB,GAAG,UAAU,CAAC;aACtC;QACF,CAAC,CAAC,CAAC;QACH,OAAO,CACN,IAAI,CAAC,cAAc,KAAK,SAAS;YACjC,IAAI,CAAC,mBAAmB,KAAK,SAAS,CACtC,CAAC;IACH,CAAC;IAEM,OAAO,CAAC,MAAc;QAM5B,IAAI,SAAiC,CAAC;QACtC,IAAI,IAAI,CAAC,mBAAmB,KAAK,SAAS,EAAE;YAC3C,SAAS,GAAG,IAAI,CAAC,mBAAmB,CAAC;SACrC;aAAM,IAAI,IAAI,CAAC,cAAc,KAAK,SAAS,EAAE;YAC7C,SAAS,GAAG,IAAI,CAAC,cAAc,CAAC;SAChC;aAAM;YACN,OAAO,OAAO,CAAC,MAAM,CACpB,qEAAqE,CACrE,CAAC;SACF;QAGD,MAAM,IAAI,GAAyC;YAClD,UAAU,EAAE,MAAM,CAAC,YAAY;YAC/B,kBAAkB,EAAE,MAAM,CAAC,UAAU;SACrC,CAAC;QAEF,OAAO,OAAO,CAAC,OAAO,CAAC,CAAC;gBACvB,IAAI,EAAE,YAAY;gBAClB,IAAI,EAAE,SAAS,CAAC,CAAC,CAAC,CAAC,IAAI;gBACvB,QAAQ,EAAE,IAAI,MAAM,CAAC,kBAAkB,CAAC,OAAO,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,QAAQ,CAAC,QAAQ,EAAE,EAAE,IAAI,CAAC,CAAC;aACxF,CAAC,CAAC,CAAC;IACL,CAAC;CACD;AAjED,yCAiEC","file":"archDockerfile.js","sourcesContent":["import * as Promise from 'bluebird';\nimport * as path from 'path';\n\nimport * as DockerfileTemplate from 'dockerfile-template';\n\nimport { Bundle, FileInfo, Resolver } from '../resolver';\n\n// Internal tuple to pass files and their extensions around\n// the class\n// ArchSpecificDockerfile = [extension, file info]\ntype ArchSpecificDockerfile = [string, FileInfo];\n\nexport default class ArchDockerfileResolver implements Resolver {\n\tpublic priority = 3;\n\tpublic name = 'Archicture-specific Dockerfile';\n\n\tprivate archDockerfiles: ArchSpecificDockerfile[] = [];\n\tprivate satisifiedArch: ArchSpecificDockerfile;\n\tprivate satisfiedDeviceType: ArchSpecificDockerfile;\n\n\tpublic entry(file: FileInfo): void {\n\t\tif (file.name.substr(0, file.name.indexOf('.')) === 'Dockerfile') {\n\t\t\t// If it's a dockerfile with an extension, save it\n\t\t\t// unless it's a Dockerfile.template, in which case don't\n\n\t\t\t// Remove the . from the start of the extension\n\t\t\tconst ext = path.extname(file.name).substr(1);\n\t\t\tif (ext !== 'template') {\n\t\t\t\tthis.archDockerfiles.push([ext, file]);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic isSatisfied(bundle: Bundle): boolean {\n\t\t// Check for both satisfied architecture and device type\n\t\tthis.archDockerfiles.map(dockerfile => {\n\t\t\tif (dockerfile[0] === bundle.architecture) {\n\t\t\t\tthis.satisifiedArch = dockerfile;\n\t\t\t} else if (dockerfile[0] === bundle.deviceType) {\n\t\t\t\tthis.satisfiedDeviceType = dockerfile;\n\t\t\t}\n\t\t});\n\t\treturn (\n\t\t\tthis.satisifiedArch !== undefined ||\n\t\t\tthis.satisfiedDeviceType !== undefined\n\t\t);\n\t}\n\n\tpublic resolve(bundle: Bundle): Promise<FileInfo[]> {\n\t\t// Return the satisfied arch/deviceType specific dockerfile,\n\t\t// as a plain Dockerfile, and the docker daemon will then\n\t\t// execute that\n\n\t\t// device type takes precedence\n\t\tlet satisfied: ArchSpecificDockerfile;\n\t\tif (this.satisfiedDeviceType !== undefined) {\n\t\t\tsatisfied = this.satisfiedDeviceType;\n\t\t} else if (this.satisifiedArch !== undefined) {\n\t\t\tsatisfied = this.satisifiedArch;\n\t\t} else {\n\t\t\treturn Promise.reject(\n\t\t\t\t'Resolve called without a satisfied architecture specific dockerfile',\n\t\t\t);\n\t\t}\n\n\t\t// Generate the variables to replace\n\t\tconst vars: DockerfileTemplate.TemplateVariables = {\n\t\t\tRESIN_ARCH: bundle.architecture,\n\t\t\tRESIN_MACHINE_NAME: bundle.deviceType,\n\t\t};\n\n\t\treturn Promise.resolve([{\n\t\t\tname: 'Dockerfile',\n\t\t\tsize: satisfied[1].size,\n\t\t\tcontents: new Buffer(DockerfileTemplate.process(satisfied[1].contents.toString(), vars)),\n\t\t}]);\n\t}\n}\n"],"sourceRoot":"../src"}