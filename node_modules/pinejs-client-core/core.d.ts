export declare function PinejsClientCoreFactory(Promise: PinejsClientCoreFactory.PromiseRejector): typeof PinejsClientCoreFactory.PinejsClientCore;
export declare namespace PinejsClientCoreFactory {
    abstract class PinejsClientCore<T, PromiseObj extends PromiseLike<{}> = Promise<{}>, PromiseResult extends PromiseLike<number | AnyObject | AnyObject[]> = Promise<number | AnyObject | AnyObject[]>> {
        apiPrefix: string;
        passthrough: AnyObject;
        passthroughByMethod: AnyObject;
        backendParams: AnyObject;
        constructor(params: string | Params, backendParams?: AnyObject);
        clone(params: string | Params, backendParams?: AnyObject): T;
        query(params: Params): PromiseResult;
        get(params: Params): PromiseResult;
        put(params: Params): PromiseObj;
        patch(params: Params): PromiseObj;
        post(params: Params): PromiseObj;
        delete(params: Params): PromiseObj;
        compile(params: Params): string;
        request(params: Params, overrides?: {
            method?: ODataMethod;
        }): PromiseObj;
        abstract _request(params: {
            method: string;
            url: string;
            body?: AnyObject;
        } & AnyObject): PromiseObj;
    }
    type PromiseResultTypes = number | PinejsClientCoreFactory.AnyObject | PinejsClientCoreFactory.AnyObject[];
    interface PromiseRejector {
        reject(err: any): PromiseLike<any>;
    }
    interface ResourceObj<T> {
        [index: string]: T;
    }
    type FilterOperationKey = '$ne' | '$eq' | '$gt' | '$ge' | '$lt' | '$le' | '$add' | '$sub' | '$mul' | '$div' | '$mod';
    type FilterOperationValue = Filter;
    type FilterFunctionKey = '$contains' | '$endswith' | '$startswith' | '$length' | '$indexof' | '$substring' | '$tolower' | '$toupper' | '$trim' | '$concat' | '$year' | '$month' | '$day' | '$hour' | '$minute' | '$second' | '$fractionalseconds' | '$date' | '$time' | '$totaloffsetminutes' | '$now' | '$maxdatetime' | '$mindatetime' | '$totalseconds' | '$round' | '$floor' | '$ceiling' | '$isof' | '$cast';
    type FilterFunctionValue = Filter;
    interface FilterObj extends ResourceObj<Filter | undefined> {
        $raw?: RawFilter;
        $?: string | string[];
        $and?: Filter;
        $or?: Filter;
        $in?: Filter;
        $not?: Filter;
        $any?: Lambda;
        $all?: Lambda;
        $ne?: FilterOperationValue;
        $eq?: FilterOperationValue;
        $gt?: FilterOperationValue;
        $ge?: FilterOperationValue;
        $lt?: FilterOperationValue;
        $le?: FilterOperationValue;
        $add?: FilterOperationValue;
        $sub?: FilterOperationValue;
        $mul?: FilterOperationValue;
        $div?: FilterOperationValue;
        $mod?: FilterOperationValue;
        $contains?: FilterFunctionValue;
        $endswith?: FilterFunctionValue;
        $startswith?: FilterFunctionValue;
        $length?: FilterFunctionValue;
        $indexof?: FilterFunctionValue;
        $substring?: FilterFunctionValue;
        $tolower?: FilterFunctionValue;
        $toupper?: FilterFunctionValue;
        $trim?: FilterFunctionValue;
        $concat?: FilterFunctionValue;
        $year?: FilterFunctionValue;
        $month?: FilterFunctionValue;
        $day?: FilterFunctionValue;
        $hour?: FilterFunctionValue;
        $minute?: FilterFunctionValue;
        $second?: FilterFunctionValue;
        $fractionalseconds?: FilterFunctionValue;
        $date?: FilterFunctionValue;
        $time?: FilterFunctionValue;
        $totaloffsetminutes?: FilterFunctionValue;
        $now?: FilterFunctionValue;
        $maxdatetime?: FilterFunctionValue;
        $mindatetime?: FilterFunctionValue;
        $totalseconds?: FilterFunctionValue;
        $round?: FilterFunctionValue;
        $floor?: FilterFunctionValue;
        $ceiling?: FilterFunctionValue;
        $isof?: FilterFunctionValue;
        $cast?: FilterFunctionValue;
    }
    interface FilterArray extends Array<Filter> {
    }
    type FilterBaseType = string | number | null | boolean | Date;
    type RawFilter = string | (string | Filter)[] | {
        $string: string;
        [index: string]: Filter;
    };
    type Lambda = {
        $alias: string;
        $expr: Filter;
    };
    type Filter = FilterObj | FilterArray | FilterBaseType;
    interface ResourceExpand extends ResourceObj<ODataOptions> {
    }
    type Expand = string | ResourceExpand | Array<string | ResourceExpand>;
    type OrderBy = string | string[] | {
        [index: string]: 'asc' | 'desc';
    };
    interface ODataOptions {
        $filter?: Filter;
        $expand?: Expand;
        $orderby?: OrderBy;
        $top?: number;
        $skip?: number;
        $select?: string | string[];
        [index: string]: undefined | number | string | string[] | Filter | Expand | OrderBy;
    }
    type OptionsObject = ODataOptions;
    type ODataMethod = 'GET' | 'POST' | 'PUT' | 'PATCH' | 'DELETE';
    type ResourceId = string | number | Date;
    type SharedParam = 'apiPrefix' | 'passthrough' | 'passthroughByMethod';
    type AnyObject = {
        [index: string]: any;
    };
    interface ParamsObj {
        apiPrefix?: string;
        method?: ODataMethod;
        resource?: string;
        id?: ResourceId;
        url?: string;
        body?: AnyObject;
        passthrough?: AnyObject;
        passthroughByMethod?: {
            GET: AnyObject;
            POST: AnyObject;
            PATCH: AnyObject;
            DELETE: AnyObject;
        };
        options?: ODataOptions;
    }
    type Params = ParamsObj | string;
    interface SubscribeParamsObj extends ParamsObj {
        pollInterval?: number;
    }
    type SubscribeParams = SubscribeParamsObj | string;
}
