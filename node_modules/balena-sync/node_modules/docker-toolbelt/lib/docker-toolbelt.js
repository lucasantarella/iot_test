// Generated by CoffeeScript 1.12.6
(function() {
  var Docker, EEXIST, MIN_PAGE_SIZE, Promise, aufsMountWithDisposer, createChainId, createChainIdFromParent, crypto, digest, es, execAsync, fs, getAllChainIds, getCacheId, getDiffIds, getRandomFileName, ignore, overlay2MountWithDisposer, path, pathPrefixRemover, randomstring, semver, sha256sum, tar;

  crypto = require('crypto');

  Promise = require('bluebird');

  Docker = require('dockerode');

  semver = require('semver');

  tar = require('tar-stream');

  es = require('event-stream');

  fs = Promise.promisifyAll(require('fs'));

  path = require('path');

  randomstring = require('randomstring');

  execAsync = Promise.promisify(require('child_process').exec);

  Promise.promisifyAll(Docker.prototype, {
    filter: function(name) {
      return name === 'run';
    },
    multiArgs: true
  });

  Promise.promisifyAll(Docker.prototype);

  Promise.promisifyAll(Docker({}).getImage().constructor.prototype);

  Promise.promisifyAll(Docker({}).getContainer().constructor.prototype);

  module.exports = Docker;

  sha256sum = function(data) {
    var hash;
    hash = crypto.createHash('sha256');
    hash.update(data);
    return hash.digest('hex');
  };

  digest = function(data) {
    return 'sha256:' + sha256sum(data);
  };

  createChainId = function(diffIds) {
    return createChainIdFromParent('', diffIds);
  };

  getAllChainIds = function(diffIds) {
    var chainIds, i, j, ref;
    chainIds = [diffIds[0]];
    for (i = j = 0, ref = diffIds.length - 1; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
      chainIds.push(createChainIdFromParent(chainIds[i], [diffIds[i + 1]]));
    }
    return chainIds;
  };

  createChainIdFromParent = function(parent, dgsts) {
    var dgst;
    if (dgsts.length === 0) {
      return parent;
    }
    if (parent === '') {
      return createChainIdFromParent(dgsts[0], dgsts.slice(1));
    }
    dgst = digest(parent + ' ' + dgsts[0]);
    return createChainIdFromParent(dgst, dgsts.slice(1));
  };

  getDiffIds = Promise.method(function(dkroot, driver, imageId) {
    var hash, hashType, ref;
    ref = imageId.split(':'), hashType = ref[0], hash = ref[1];
    return fs.readFileAsync(path.join(dkroot, "image/" + driver + "/imagedb/content", hashType, hash)).then(JSON.parse).get('rootfs').get('diff_ids');
  });

  getCacheId = Promise.method(function(dkroot, driver, layerId) {
    var cacheIdPath, hash, hashType, ref;
    ref = layerId.split(':'), hashType = ref[0], hash = ref[1];
    cacheIdPath = path.join(dkroot, "image/" + driver + "/layerdb", hashType, hash, 'cache-id');
    return fs.readFileAsync(cacheIdPath, {
      encoding: 'utf8'
    });
  });

  getRandomFileName = function(imageId) {
    return "tmp-" + (imageId.split(':')[1]) + "-" + (randomstring.generate(8));
  };

  Docker.prototype.imageRootDir = function(image) {
    return Promise.join(this.infoAsync(), this.versionAsync().get('Version'), this.getImage(image).inspectAsync(), function(dockerInfo, dockerVersion, imageInfo) {
      var dkroot, imageId;
      dkroot = dockerInfo.DockerRootDir;
      imageId = imageInfo.Id;
      return Promise["try"](function() {
        if (semver.lt(dockerVersion, '1.10.0', true)) {
          return imageId;
        }
        return getDiffIds(dkroot, dockerInfo.Driver, imageId).then(function(diffIds) {
          var layerId;
          layerId = createChainId(diffIds);
          return getCacheId(dkroot, dockerInfo.Driver, layerId);
        });
      }).then(function(destId) {
        switch (dockerInfo.Driver) {
          case 'btrfs':
            return path.join(dkroot, 'btrfs/subvolumes', destId);
          case 'overlay':
            return imageInfo.GraphDriver.Data.RootDir;
          case 'overlay2':
            return imageInfo.GraphDriver.Data.UpperDir;
          case 'vfs':
            return path.join(dkroot, 'vfs/dir', destId);
          case 'aufs':
            return path.join(dkroot, 'aufs/diff', destId);
          default:
            throw new Error("Unsupported driver: " + dockerInfo.Driver + "/");
        }
      });
    });
  };

  EEXIST = {
    code: 'EEXIST'
  };

  ignore = function() {};

  MIN_PAGE_SIZE = 4096;

  pathPrefixRemover = function(prefix) {
    return function(path) {
      var slice;
      slice = path.substr(prefix.length);
      if (("" + prefix + slice) === path) {
        return slice;
      } else {
        return path;
      }
    };
  };

  overlay2MountWithDisposer = function(fsRoot, target, lowers, diffDir, workDir) {
    if (!lowers) {
      return Promise.resolve(diffDir);
    }
    return fs.mkdirAsync(target)["catch"](EEXIST, ignore).then(function() {
      var makeRelative, mountOpts, options;
      options = "lowerdir=" + lowers + ",upperdir=" + diffDir + ",workdir=" + workDir;
      mountOpts = {};
      if (options.length > MIN_PAGE_SIZE) {
        mountOpts.cwd = fsRoot;
        makeRelative = pathPrefixRemover(path.join(fsRoot, path.sep));
        options = ["lowerdir=" + (lowers.split(':').map(makeRelative).join(':')), "upperdir=" + (makeRelative(diffDir)), "workdir=" + (makeRelative(workDir))].join(',');
      }
      return execAsync("mount -t overlay -o '" + options + "' none " + target, mountOpts);
    })["return"](target).disposer(function(target) {
      return execAsync("umount " + target).then(function() {
        return fs.rmdirAsync(target);
      })["catch"](function(err) {
        console.error('Failed to clean up after mounting overlay2', err, err.stack);
      });
    });
  };

  aufsMountWithDisposer = function(target, layerDiffPaths) {
    return fs.mkdirAsync(target)["catch"](EEXIST, ignore).then(function() {
      var appendFromIndex, appendLayerPaths, options, remainingBytes;
      options = 'noxino,ro,br=';
      remainingBytes = MIN_PAGE_SIZE - options.length;
      layerDiffPaths = layerDiffPaths.map(function(path) {
        return path + "=ro+wh";
      });
      appendFromIndex = layerDiffPaths.findIndex(function(path) {
        remainingBytes -= path.length + 1;
        return remainingBytes < -1;
      });
      if (appendFromIndex === -1) {
        appendFromIndex = layerDiffPaths.length;
      }
      appendLayerPaths = layerDiffPaths.slice(appendFromIndex);
      options += layerDiffPaths.slice(0, appendFromIndex).join(':');
      return execAsync("mount -t aufs -o '" + options + "' none " + target).then(function() {
        return Promise.mapSeries(appendLayerPaths, function(path) {
          return execAsync("mount -t aufs -o 'remount,append:" + path + "' none " + target);
        });
      });
    })["return"](target).disposer(function(target) {
      return execAsync("umount " + target).then(function() {
        return fs.rmdirAsync(target);
      })["catch"](function(err) {
        console.error('Failed to clean up after mounting aufs', err, err.stack);
      });
    });
  };

  Docker.prototype.imageRootDirMounted = function(image) {
    return Promise.join(this.infoAsync(), this.versionAsync().get('Version'), this.getImage(image).inspectAsync(), (function(_this) {
      return function(dockerInfo, dockerVersion, imageInfo) {
        var LowerDir, MergedDir, UpperDir, WorkDir, dkroot, driver, imageId, mountDir, ref, rootDir;
        driver = dockerInfo.Driver;
        dkroot = dockerInfo.DockerRootDir;
        imageId = imageInfo.Id;
        if (driver === 'aufs') {
          return _this.diffPaths(image).then(function(layerDiffPaths) {
            var mountDir;
            mountDir = path.join(dkroot, 'aufs/mnt', getRandomFileName(imageId));
            return aufsMountWithDisposer(mountDir, layerDiffPaths);
          });
        } else if (driver === 'overlay2') {
          rootDir = path.join(dkroot, 'overlay2');
          mountDir = path.join(rootDir, getRandomFileName(imageId));
          ref = imageInfo.GraphDriver.Data, LowerDir = ref.LowerDir, UpperDir = ref.UpperDir, MergedDir = ref.MergedDir, WorkDir = ref.WorkDir;
          return overlay2MountWithDisposer(rootDir, mountDir, LowerDir, UpperDir, WorkDir);
        } else {
          return _this.imageRootDir(image);
        }
      };
    })(this));
  };

  Docker.prototype.diffPaths = function(image) {
    return Promise.join(this.infoAsync(), this.versionAsync().get('Version'), this.getImage(image).inspectAsync(), function(dockerInfo, dockerVersion, imageInfo) {
      var dkroot, driver, imageId;
      driver = dockerInfo.Driver;
      if (driver !== 'aufs' && driver !== 'overlay2') {
        throw new Error('diffPaths can only be used on aufs and overlay2');
      }
      dkroot = dockerInfo.DockerRootDir;
      imageId = imageInfo.Id;
      return getDiffIds(dkroot, driver, imageId).then(function(diffIds) {
        if (semver.lt(dockerVersion, '1.10.0', true)) {
          return diffIds;
        }
        return Promise.map(getAllChainIds(diffIds), function(layerId) {
          return getCacheId(dkroot, driver, layerId);
        });
      }).call('reverse').map(function(layerId) {
        switch (driver) {
          case 'aufs':
            return path.join(dkroot, 'aufs/diff', layerId);
          case 'overlay2':
            return path.join(dkroot, 'overlay2', layerId, 'diff');
        }
      });
    });
  };

  Docker.prototype.aufsDiffPaths = Docker.prototype.diffPaths;

  Docker.prototype.createEmptyImage = function(imageConfig) {
    var layer, manifest;
    manifest = [
      {
        Config: 'config.json',
        RepoTags: null,
        Layers: ['0000/layer.tar']
      }
    ];
    layer = tar.pack();
    layer.entry({
      name: 'seed'
    }, String(Date.now() + Math.random()));
    layer.finalize();
    return Promise.fromCallback(function(callback) {
      return layer.pipe(es.wait(callback));
    }).then((function(_this) {
      return function(buf) {
        var config, image, imageId, layerConfig, now;
        now = (new Date()).toISOString();
        config = {
          config: imageConfig,
          created: now,
          rootfs: {
            type: 'layers',
            diff_ids: [digest(buf)]
          }
        };
        imageId = sha256sum(JSON.stringify(config));
        layerConfig = {
          id: imageId,
          created: now,
          config: imageConfig
        };
        image = tar.pack();
        image.entry({
          name: 'manifest.json'
        }, JSON.stringify(manifest));
        image.entry({
          name: 'config.json'
        }, JSON.stringify(config));
        image.entry({
          name: '0000/VERSION'
        }, '1.0');
        image.entry({
          name: '0000/json'
        }, JSON.stringify(layerConfig));
        image.entry({
          name: '0000/layer.tar'
        }, buf);
        image.finalize();
        return _this.loadImageAsync(image).then(function(stream) {
          return Promise.fromCallback(function(callback) {
            return stream.pipe(es.wait(callback));
          });
        })["return"](imageId);
      };
    })(this));
  };

  Docker.prototype.getRegistryAndName = Promise.method(function(image) {
    var imageName, j, match, ref, ref1, registry, tagName;
    match = image.match(/^(?:([^\/:.]+\.[^\/:]+(?::[0-9]+)?)\/)?([^\/:]+(?:\/[^\/:]+)?)(?::(.*))?$/);
    if (match == null) {
      throw new Error("Could not parse the image: " + image);
    }
    j = match.length - 3, registry = (ref = match[j++]) != null ? ref : 'docker.io', imageName = match[j++], tagName = (ref1 = match[j++]) != null ? ref1 : 'latest';
    if (!imageName) {
      throw new Error('Invalid image name, expected domain.tld/repo/image format.');
    }
    return {
      registry: registry,
      imageName: imageName,
      tagName: tagName
    };
  });

}).call(this);
