"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const BlockMap = require("blockmap");
const Bluebird = require("bluebird");
const crypto_1 = require("crypto");
function getNotDiscardedChunks(disk, capacity) {
    const chunks = [];
    const discardedChunks = disk.getDiscardedChunks();
    let lastStart = 0;
    for (const discardedChunk of discardedChunks) {
        chunks.push([lastStart, discardedChunk.start - 1]);
        lastStart = discardedChunk.end + 1;
    }
    if (lastStart < capacity) {
        chunks.push([lastStart, capacity - 1]);
    }
    return chunks;
}
function* mergeBlocks(blocks) {
    // Merges adjacent and overlapping blocks (helper for getBlockMap).
    let current;
    for (const block of blocks) {
        if (current === undefined) {
            current = block.slice(); // slice for copying
        }
        else if (block[0] > current[1] + 1) {
            // There's a gap
            yield current;
            current = block.slice(); // slice for copying
        }
        else {
            // No gap
            current[1] = block[1];
        }
    }
    if (current !== undefined) {
        yield current;
    }
}
function streamSha256(stream) {
    return __awaiter(this, void 0, void 0, function* () {
        const hash = crypto_1.createHash('sha256');
        return yield new Promise((resolve, reject) => {
            stream.on('error', reject);
            hash.on('error', reject);
            hash.on('finish', () => {
                resolve(hash.read().toString('hex'));
            });
            stream.pipe(hash);
        });
    });
}
function getRanges(disk, blocks, blockSize, calculateChecksums) {
    return __awaiter(this, void 0, void 0, function* () {
        const result = blocks.map(block => {
            return { start: block[0], end: block[1], checksum: null };
        });
        if (!calculateChecksums) {
            return result;
        }
        yield Bluebird.each(blocks, (block, i) => __awaiter(this, void 0, void 0, function* () {
            const start = block[0] * blockSize;
            const length = (block[1] - block[0] + 1) * blockSize;
            const stream = yield disk.getStream(start, length);
            result[i].checksum = yield streamSha256(stream);
        }));
        return result;
    });
}
function calculateBmapSha256(bmap) {
    bmap.checksum = Array(64).join('0');
    const hash = crypto_1.createHash('sha256');
    hash.update(bmap.toString());
    bmap.checksum = hash.digest('hex');
}
function getBlockMap(disk, blockSize, capacity, calculateChecksums) {
    return __awaiter(this, void 0, void 0, function* () {
        const chunks = getNotDiscardedChunks(disk, capacity);
        let blocks = chunks.map((chunk) => {
            return [
                Math.floor(chunk[0] / blockSize),
                Math.floor(chunk[1] / blockSize),
            ];
        });
        blocks = Array.from(mergeBlocks(blocks));
        const mappedBlockCount = blocks
            .map(block => {
            return block[1] - block[0] + 1;
        })
            .reduce((a, b) => {
            return a + b;
        });
        const ranges = yield getRanges(disk, blocks, blockSize, calculateChecksums);
        const bmap = new BlockMap({
            imageSize: capacity,
            blockSize,
            blockCount: Math.ceil(capacity / blockSize),
            mappedBlockCount,
            ranges,
        });
        calculateBmapSha256(bmap);
        return bmap;
    });
}
exports.getBlockMap = getBlockMap;
//# sourceMappingURL=blockmap.js.map