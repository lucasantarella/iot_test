"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const Bluebird = require("bluebird");
const Docker = require("dockerode");
const _ = require("lodash");
const semver = require("resin-semver");
const Logger = require("../logger");
const logs_1 = require("./logs");
const LocalPushErrors = require("./errors");
const logger = new Logger();
function checkSource(source) {
    return __awaiter(this, void 0, void 0, function* () {
        const { fs } = yield Promise.resolve().then(() => require('mz'));
        return (yield fs.exists(source)) && (yield fs.stat(source)).isDirectory();
    });
}
function deployToDevice(opts) {
    return __awaiter(this, void 0, void 0, function* () {
        const { loadProject, tarDirectory } = yield Promise.resolve().then(() => require('../compose'));
        const { exitWithExpectedError } = yield Promise.resolve().then(() => require('../patterns'));
        const { DeviceAPI } = yield Promise.resolve().then(() => require('./api'));
        const { displayDeviceLogs } = yield Promise.resolve().then(() => require('./logs'));
        if (!(yield checkSource(opts.source))) {
            exitWithExpectedError(`Could not access source directory: ${opts.source}`);
        }
        const api = new DeviceAPI(logger, opts.deviceHost);
        try {
            yield api.ping();
        }
        catch (e) {
            exitWithExpectedError(`Could not communicate with local mode device at address ${opts.deviceHost}`);
        }
        const versionError = new Error('The supervisor version on this remote device does not support multicontainer local mode. ' +
            'Please update your device to balenaOS v2.20.0 or greater from the dashboard.');
        try {
            const version = yield api.getVersion();
            if (!semver.satisfies(version, '>=7.21.4')) {
                exitWithExpectedError(versionError);
            }
        }
        catch (_a) {
            exitWithExpectedError(versionError);
        }
        logger.logInfo(`Starting build on device ${opts.deviceHost}`);
        const project = yield loadProject(logger, opts.source, 'local');
        const docker = connectToDocker(opts.deviceHost, opts.devicePort != null ? opts.devicePort : 2375);
        const tarStream = yield tarDirectory(opts.source);
        const deviceInfo = yield api.getDeviceInformation();
        yield performBuilds(project.composition, tarStream, docker, deviceInfo, logger, opts);
        logger.logDebug('Setting device state...');
        const currentTargetState = yield api.getTargetState();
        const targetState = generateTargetState(currentTargetState, project.composition);
        logger.logDebug(`Sending target state: ${JSON.stringify(targetState)}`);
        yield api.setTargetState(targetState);
        console.log();
        logger.logInfo('Streaming device logs...');
        const logStream = yield api.getLogStream();
        yield displayDeviceLogs(logStream, logger);
    });
}
exports.deployToDevice = deployToDevice;
function connectToDocker(host, port) {
    return new Docker({
        host,
        port,
        Promise: Bluebird,
    });
}
function performBuilds(composition, tarStream, docker, deviceInfo, logger, opts) {
    return __awaiter(this, void 0, void 0, function* () {
        const multibuild = yield Promise.resolve().then(() => require('resin-multibuild'));
        const buildTasks = yield multibuild.splitBuildStream(composition, tarStream);
        logger.logDebug('Found build tasks:');
        _.each(buildTasks, task => {
            let infoStr;
            if (task.external) {
                infoStr = `image pull [${task.imageName}]`;
            }
            else {
                infoStr = `build [${task.context}]`;
            }
            logger.logDebug(`    ${task.serviceName}: ${infoStr}`);
        });
        logger.logDebug(`Resolving services with [${deviceInfo.deviceType}|${deviceInfo.arch}]`);
        yield multibuild.performResolution(buildTasks, deviceInfo.arch, deviceInfo.deviceType);
        logger.logDebug('Found project types:');
        _.each(buildTasks, task => {
            if (!task.external) {
                logger.logDebug(`    ${task.serviceName}: ${task.projectType}`);
            }
            else {
                logger.logDebug(`    ${task.serviceName}: External image`);
            }
        });
        logger.logDebug('Probing remote daemon for cache images');
        yield assignDockerBuildOpts(docker, buildTasks, opts);
        logger.logDebug('Starting builds...');
        yield assignOutputHandlers(buildTasks, logger);
        const localImages = yield multibuild.performBuilds(buildTasks, docker);
        yield inspectBuildResults(localImages);
        yield Bluebird.map(localImages, (localImage) => __awaiter(this, void 0, void 0, function* () {
            if (localImage.external) {
                const image = docker.getImage(localImage.name);
                yield image.tag({
                    repo: generateImageName(localImage.serviceName),
                    force: true,
                });
                yield image.remove({ force: true });
            }
        }));
    });
}
exports.performBuilds = performBuilds;
function assignOutputHandlers(buildTasks, logger) {
    _.each(buildTasks, task => {
        if (task.external) {
            task.progressHook = progressObj => {
                logs_1.displayBuildLog({ serviceName: task.serviceName, message: progressObj.progress }, logger);
            };
        }
        else {
            task.streamHook = stream => {
                stream.on('data', (buf) => {
                    const str = _.trimEnd(buf.toString());
                    if (str !== '') {
                        logs_1.displayBuildLog({ serviceName: task.serviceName, message: str }, logger);
                    }
                });
            };
        }
    });
}
function getDeviceDockerImages(docker) {
    return __awaiter(this, void 0, void 0, function* () {
        const images = yield docker.listImages();
        return _.map(images, 'Id');
    });
}
function assignDockerBuildOpts(docker, buildTasks, opts) {
    return __awaiter(this, void 0, void 0, function* () {
        const images = yield getDeviceDockerImages(docker);
        logger.logDebug(`Using ${images.length} on-device images for cache...`);
        _.each(buildTasks, (task) => {
            task.dockerOpts = {
                cachefrom: images,
                labels: {
                    'io.resin.local.image': '1',
                    'io.resin.local.service': task.serviceName,
                },
                registryconfig: opts.registrySecrets,
                t: generateImageName(task.serviceName),
            };
        });
    });
}
function generateImageName(serviceName) {
    return `local_image_${serviceName}:latest`;
}
function generateTargetState(currentTargetState, composition) {
    const services = {};
    let idx = 1;
    _.each(composition.services, (opts, name) => {
        opts = _.cloneDeep(opts);
        delete opts.build;
        delete opts.image;
        const defaults = {
            environment: {},
            labels: {},
        };
        services[idx] = _.merge(defaults, opts, {
            imageId: idx,
            serviceName: name,
            serviceId: idx,
            image: generateImageName(name),
            running: true,
        });
        idx += 1;
    });
    const targetState = _.cloneDeep(currentTargetState);
    delete targetState.local.apps;
    targetState.local.apps = {
        1: {
            name: 'localapp',
            commit: 'localcommit',
            releaseId: '1',
            services,
            volumes: composition.volumes || {},
            networks: composition.networks || {},
        },
    };
    return targetState;
}
function inspectBuildResults(images) {
    return __awaiter(this, void 0, void 0, function* () {
        const { exitWithExpectedError } = yield Promise.resolve().then(() => require('../patterns'));
        const failures = [];
        _.each(images, image => {
            if (!image.successful) {
                failures.push({
                    error: image.error,
                    serviceName: image.serviceName,
                });
            }
        });
        if (failures.length > 0) {
            exitWithExpectedError(new LocalPushErrors.BuildError(failures).toString());
        }
    });
}
//# sourceMappingURL=deploy.js.map