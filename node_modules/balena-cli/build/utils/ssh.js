"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const child_process_1 = require("child_process");
const Bluebird = require("bluebird");
const typed_error_1 = require("typed-error");
const helpers_1 = require("./helpers");
class ExecError extends typed_error_1.TypedError {
    constructor(cmd, exitCode) {
        super(`Command '${cmd}' failed with error: ${exitCode}`);
        this.cmd = cmd;
        this.exitCode = exitCode;
    }
}
exports.ExecError = ExecError;
function exec(deviceIp, cmd, stdout) {
    return __awaiter(this, void 0, void 0, function* () {
        const command = `ssh \
		-t \
		-p 22222 \
		-o LogLevel=ERROR \
		-o StrictHostKeyChecking=no \
		-o UserKnownHostsFile=/dev/null \
		root@${deviceIp} \
		${cmd}`;
        const stdio = ['ignore', stdout ? 'pipe' : 'inherit', 'ignore'];
        const { program, args } = helpers_1.getSubShellCommand(command);
        const exitCode = yield new Bluebird((resolve, reject) => {
            const ps = child_process_1.spawn(program, args, { stdio })
                .on('error', reject)
                .on('close', resolve);
            if (stdout) {
                ps.stdout.pipe(stdout);
            }
        });
        if (exitCode != 0) {
            throw new ExecError(cmd, exitCode);
        }
    });
}
exports.exec = exec;
function execBuffered(deviceIp, cmd, enc) {
    return __awaiter(this, void 0, void 0, function* () {
        const through = yield Promise.resolve().then(() => require('through2'));
        const buffer = [];
        yield exec(deviceIp, cmd, through(function (data, _enc, cb) {
            buffer.push(data.toString(enc));
            cb();
        }));
        return buffer.join('');
    });
}
exports.execBuffered = execBuffered;
//# sourceMappingURL=ssh.js.map