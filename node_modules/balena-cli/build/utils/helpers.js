"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const os = require("os");
const Bluebird = require("bluebird");
const _ = require("lodash");
const chalk_1 = require("chalk");
const rindle = require("rindle");
const visuals = require("resin-cli-visuals");
const BalenaSdk = require("balena-sdk");
const waitStreamAsync = Bluebird.promisify(rindle.wait);
const balena = BalenaSdk.fromSharedOptions();
function getGroupDefaults(group) {
    return _.chain(group)
        .get('options')
        .map(question => [question.name, question.default])
        .fromPairs()
        .value();
}
exports.getGroupDefaults = getGroupDefaults;
function stateToString(state) {
    const percentage = _.padStart(`${state.percentage}`, 3, '0');
    const result = `${chalk_1.default.blue(percentage + '%')} ${chalk_1.default.cyan(state.operation.command)}`;
    switch (state.operation.command) {
        case 'copy':
            return `${result} ${state.operation.from.path} -> ${state.operation.to.path}`;
        case 'replace':
            return `${result} ${state.operation.file.path}, ${state.operation.copy} -> ${state.operation.replace}`;
        case 'run-script':
            return `${result} ${state.operation.script}`;
        default:
            throw new Error(`Unsupported operation: ${state.operation.command}`);
    }
}
exports.stateToString = stateToString;
function sudo(command, { stderr, msg } = {}) {
    const { executeWithPrivileges } = require('./sudo');
    if (os.platform() !== 'win32') {
        console.log(msg || 'If asked please type your computer password to continue');
    }
    return executeWithPrivileges(command, stderr);
}
exports.sudo = sudo;
function runCommand(command) {
    const capitano = require('capitano');
    return Bluebird.fromCallback(resolver => capitano.run(command, resolver));
}
exports.runCommand = runCommand;
function getManifest(image, deviceType) {
    return __awaiter(this, void 0, void 0, function* () {
        const init = yield Promise.resolve().then(() => require('balena-device-init'));
        const manifest = yield init.getImageManifest(image);
        if (manifest != null) {
            return manifest;
        }
        return balena.models.device.getManifestBySlug(deviceType);
    });
}
exports.getManifest = getManifest;
exports.areDeviceTypesCompatible = (deviceTypeA, deviceTypeB) => deviceTypeA.arch === deviceTypeB.arch &&
    !!deviceTypeA.isDependent === !!deviceTypeB.isDependent;
function getOsVersion(image, manifest) {
    return __awaiter(this, void 0, void 0, function* () {
        const init = yield Promise.resolve().then(() => require('balena-device-init'));
        return init.getImageOsVersion(image, manifest);
    });
}
exports.getOsVersion = getOsVersion;
function osProgressHandler(step) {
    step.on('stdout', process.stdout.write.bind(process.stdout));
    step.on('stderr', process.stderr.write.bind(process.stderr));
    step.on('state', function (state) {
        if (state.operation.command === 'burn') {
            return;
        }
        console.log(exports.stateToString(state));
    });
    const progressBars = {
        write: new visuals.Progress('Writing Device OS'),
        check: new visuals.Progress('Validating Device OS'),
    };
    step.on('burn', state => progressBars[state.type].update(state));
    return waitStreamAsync(step);
}
exports.osProgressHandler = osProgressHandler;
function getArchAndDeviceType(applicationName) {
    return Bluebird.join(getApplication(applicationName), balena.models.config.getDeviceTypes(), function (app, deviceTypes) {
        const config = _.find(deviceTypes, { slug: app.device_type });
        if (!config) {
            throw new Error('Could not read application information!');
        }
        return { device_type: app.device_type, arch: config.arch };
    });
}
exports.getArchAndDeviceType = getArchAndDeviceType;
function getApplication(applicationName) {
    const match = applicationName.split('/');
    const extraOptions = {
        $expand: {
            application_type: {
                $select: ['name', 'slug', 'supports_multicontainer', 'is_legacy'],
            },
        },
    };
    if (match.length > 1) {
        return balena.models.application.getAppByOwner(match[1], match[0], extraOptions);
    }
    return balena.models.application.get(applicationName, extraOptions);
}
exports.getApplication = getApplication;
function getSubShellCommand(command) {
    if (os.platform() === 'win32') {
        return {
            program: 'cmd.exe',
            args: ['/s', '/c', command],
        };
    }
    else {
        return {
            program: '/bin/sh',
            args: ['-c', command],
        };
    }
}
exports.getSubShellCommand = getSubShellCommand;
//# sourceMappingURL=helpers.js.map