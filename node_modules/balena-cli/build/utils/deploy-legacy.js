// Generated by CoffeeScript 1.12.7
var Promise, bufferImage, getBuilderLogPushEndpoint, getBuilderPushEndpoint, showPushProgress, uploadImage, uploadLogs, uploadToPromise;

Promise = require('bluebird');

getBuilderPushEndpoint = function(baseUrl, owner, app) {
  var args, querystring;
  querystring = require('querystring');
  args = querystring.stringify({
    owner: owner,
    app: app
  });
  return "https://builder." + baseUrl + "/v1/push?" + args;
};

getBuilderLogPushEndpoint = function(baseUrl, buildId, owner, app) {
  var args, querystring;
  querystring = require('querystring');
  args = querystring.stringify({
    owner: owner,
    app: app,
    buildId: buildId
  });
  return "https://builder." + baseUrl + "/v1/pushLogs?" + args;
};

bufferImage = function(docker, imageId, bufferFile) {
  var image, imageMetadata, streamUtils;
  Promise = require('bluebird');
  streamUtils = require('./streams');
  image = docker.getImage(imageId);
  imageMetadata = image.inspect();
  return Promise.join(image.get(), imageMetadata.get('Size'), function(imageStream, imageSize) {
    return streamUtils.buffer(imageStream, bufferFile).tap(function(bufferedStream) {
      return bufferedStream.length = imageSize;
    });
  });
};

showPushProgress = function(message) {
  var progressBar, visuals;
  visuals = require('resin-cli-visuals');
  progressBar = new visuals.Progress(message);
  progressBar.update({
    percentage: 0
  });
  return progressBar;
};

uploadToPromise = function(uploadRequest, logger) {
  return new Promise(function(resolve, reject) {
    var handleMessage;
    handleMessage = function(data) {
      var e, obj;
      data = data.toString();
      logger.logDebug("Received data: " + data);
      try {
        obj = JSON.parse(data);
      } catch (error) {
        e = error;
        logger.logError('Error parsing reply from remote side');
        reject(e);
        return;
      }
      switch (obj.type) {
        case 'error':
          return reject(new Error("Remote error: " + obj.error));
        case 'success':
          return resolve(obj);
        case 'status':
          return logger.logInfo(obj.message);
        default:
          return reject(new Error("Received unexpected reply from remote: " + data));
      }
    };
    return uploadRequest.on('error', reject).on('data', handleMessage);
  });
};

uploadImage = function(imageStream, token, username, url, appName, logger) {
  var progressBar, progressMessage, progressStream, request, streamWithProgress, uploadRequest, zlib;
  request = require('request');
  progressStream = require('progress-stream');
  zlib = require('zlib');
  progressMessage = logger.formatMessage('info', 'Uploading').slice(0, -1);
  progressBar = showPushProgress(progressMessage);
  streamWithProgress = imageStream.pipe(progressStream({
    time: 500,
    length: imageStream.length
  }, function(arg) {
    var eta, percentage;
    percentage = arg.percentage, eta = arg.eta;
    return progressBar.update({
      percentage: Math.min(percentage, 100),
      eta: eta
    });
  }));
  uploadRequest = request.post({
    url: getBuilderPushEndpoint(url, username, appName),
    headers: {
      'Content-Encoding': 'gzip'
    },
    auth: {
      bearer: token
    },
    body: streamWithProgress.pipe(zlib.createGzip({
      level: 6
    }))
  });
  return uploadToPromise(uploadRequest, logger);
};

uploadLogs = function(logs, token, url, buildId, username, appName) {
  var request;
  request = require('request');
  return request.post({
    json: true,
    url: getBuilderLogPushEndpoint(url, buildId, username, appName),
    auth: {
      bearer: token
    },
    body: Buffer.from(logs)
  });
};


/*
opts must be a hash with the following keys:

- appName: the name of the app to deploy to
- imageName: the name of the image to deploy
- buildLogs: a string with build output
- shouldUploadLogs
 */

module.exports = function(docker, logger, token, username, url, opts) {
  var appName, buildLogs, imageName, logs, shouldUploadLogs, tmp, tmpNameAsync;
  tmp = require('tmp');
  tmpNameAsync = Promise.promisify(tmp.tmpName);
  tmp.setGracefulCleanup();
  appName = opts.appName, imageName = opts.imageName, buildLogs = opts.buildLogs, shouldUploadLogs = opts.shouldUploadLogs;
  logs = buildLogs;
  return tmpNameAsync().then(function(bufferFile) {
    logger.logInfo('Initializing deploy...');
    return bufferImage(docker, imageName, bufferFile).then(function(stream) {
      return uploadImage(stream, token, username, url, appName, logger);
    })["finally"](function() {
      return Promise["try"](function() {
        return require('mz/fs').unlink(bufferFile);
      }).catchReturn();
    });
  }).tap(function(arg) {
    var buildId;
    buildId = arg.buildId;
    if (!shouldUploadLogs) {
      return;
    }
    logger.logInfo('Uploading logs...');
    return Promise.join(logs, token, url, buildId, username, appName, uploadLogs);
  }).get('buildId');
};
