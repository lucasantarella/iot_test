// Generated by CoffeeScript 1.12.7

/**
 * @license
 * Copyright 2018 Balena Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var BuildProgressInline, BuildProgressUI, LOG_LENGTH_MAX, Promise, appendProjectOptions, authorizePush, buildLogCapture, buildProgressAdapter, compositionFileNames, createLogStream, createProject, createRelease, createRunLoop, createSpinner, dropEmptyLinesStream, path, pullProgressAdapter, pushAndUpdateServiceImages, pushProgressRenderer, renderProgressBar, resolveProject, runSpinner, tagServiceImages, tarDirectory, toPosixPath, truncateString,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

Promise = require('bluebird');

path = require('path');

exports.appendProjectOptions = appendProjectOptions = function(opts) {
  return opts.concat([
    {
      signature: 'projectName',
      parameter: 'projectName',
      description: 'Specify an alternate project name; default is the directory name',
      alias: 'n'
    }
  ]);
};

exports.appendOptions = function(opts) {
  return appendProjectOptions(opts).concat([
    {
      signature: 'emulated',
      description: 'Run an emulated build using Qemu',
      boolean: true,
      alias: 'e'
    }, {
      signature: 'logs',
      description: 'Display full log output',
      boolean: true
    }
  ]);
};

exports.generateOpts = function(options) {
  var fs;
  fs = require('mz/fs');
  return fs.realpath(options.source || '.').then(function(projectPath) {
    return {
      projectName: options.projectName,
      projectPath: projectPath,
      inlineLogs: !!options.logs
    };
  });
};

compositionFileNames = ['docker-compose.yml', 'docker-compose.yaml'];

exports.resolveProject = resolveProject = function(rootDir) {
  var fs;
  fs = require('mz/fs');
  return Promise.any(compositionFileNames.map(function(filename) {
    return fs.readFile(path.join(rootDir, filename), 'utf-8');
  }));
};

createProject = function(composePath, composeStr, projectName) {
  var compose, composition, descriptors, yml;
  if (projectName == null) {
    projectName = null;
  }
  yml = require('js-yaml');
  compose = require('resin-compose-parse');
  composition = yml.safeLoad(composeStr, {
    schema: yml.FAILSAFE_SCHEMA
  });
  composition = compose.normalize(composition);
  if (projectName == null) {
    projectName = path.basename(composePath);
  }
  descriptors = compose.parse(composition).map(function(descr) {
    if ((descr.image.context != null) && (descr.image.tag == null)) {
      descr.image.tag = [projectName, descr.serviceName].join('_').toLowerCase();
    }
    return descr;
  });
  return {
    path: composePath,
    name: projectName,
    composition: composition,
    descriptors: descriptors
  };
};

exports.loadProject = function(logger, projectPath, projectName, image) {
  var compose;
  compose = require('resin-compose-parse');
  logger.logDebug('Loading project...');
  return Promise["try"](function() {
    if (image != null) {
      logger.logInfo("Creating default composition with image: " + image);
      return compose.defaultComposition(image);
    }
    logger.logDebug('Resolving project...');
    return resolveProject(projectPath).tap(function() {
      return logger.logInfo('Compose file detected');
    })["catch"](function(e) {
      logger.logDebug("Failed to resolve project: " + e);
      logger.logInfo("Creating default composition with source: " + projectPath);
      return compose.defaultComposition();
    });
  }).then(function(composeStr) {
    logger.logDebug('Creating project...');
    return createProject(projectPath, composeStr, projectName);
  });
};

toPosixPath = function(systemPath) {
  path = require('path');
  return systemPath.replace(new RegExp('\\' + path.sep, 'g'), '/');
};

exports.tarDirectory = tarDirectory = function(dir, preFinalizeCallback) {
  var FileIgnorer, fs, getFiles, ignore, klaw, pack, streamToPromise, tar;
  if (preFinalizeCallback == null) {
    preFinalizeCallback = null;
  }
  tar = require('tar-stream');
  klaw = require('klaw');
  path = require('path');
  fs = require('mz/fs');
  streamToPromise = require('stream-to-promise');
  FileIgnorer = require('./ignore').FileIgnorer;
  getFiles = function() {
    return streamToPromise(klaw(dir)).filter(function(item) {
      return !item.stats.isDirectory();
    }).map(function(item) {
      return item.path;
    });
  };
  ignore = new FileIgnorer(dir);
  pack = tar.pack();
  return getFiles(dir).each(function(file) {
    var type;
    type = ignore.getIgnoreFileType(path.relative(dir, file));
    if (type != null) {
      return ignore.addIgnoreFile(file, type);
    }
  }).filter(ignore.filter).map(function(file) {
    var relPath;
    relPath = path.relative(path.resolve(dir), file);
    return Promise.join(relPath, fs.stat(file), fs.readFile(file), function(filename, stats, data) {
      return pack.entry({
        name: toPosixPath(filename),
        size: stats.size,
        mode: stats.mode
      }, data);
    });
  }).then(function() {
    return typeof preFinalizeCallback === "function" ? preFinalizeCallback(pack) : void 0;
  }).then(function() {
    pack.finalize();
    return pack;
  });
};

truncateString = function(str, len) {
  if (str.length < len) {
    return str;
  }
  str = str.slice(0, len);
  return str.slice(0, str.lastIndexOf('\n'));
};

LOG_LENGTH_MAX = 512 * 1024;

exports.buildProject = function(docker, logger, projectPath, projectName, composition, arch, deviceType, emulated, buildOpts, inlineLogs) {
  var _, builder, compose, humanize, imageDescriptors, imageDescriptorsByServiceName, qemu, renderer, transpose, tty;
  _ = require('lodash');
  humanize = require('humanize');
  compose = require('resin-compose-parse');
  builder = require('resin-multibuild');
  transpose = require('docker-qemu-transpose');
  qemu = require('./qemu');
  logger.logInfo("Building for " + arch + "/" + deviceType);
  imageDescriptors = compose.parse(composition);
  imageDescriptorsByServiceName = _.keyBy(imageDescriptors, 'serviceName');
  if (inlineLogs) {
    renderer = new BuildProgressInline(logger.streams['build'], imageDescriptors);
  } else {
    tty = require('./tty')(process.stdout);
    renderer = new BuildProgressUI(tty, imageDescriptors);
  }
  renderer.start();
  return qemu.installQemuIfNeeded(emulated, logger, arch).tap(function(needsQemu) {
    if (!needsQemu) {
      return;
    }
    logger.logInfo('Emulation is enabled');
    return Promise.map(imageDescriptors, function(d) {
      if (d.image.context == null) {
        return;
      }
      return qemu.copyQemu(path.join(projectPath, d.image.context), arch);
    });
  }).then(function(needsQemu) {
    return tarDirectory(projectPath).then(function(tarStream) {
      return builder.splitBuildStream(composition, tarStream);
    }).tap(function(tasks) {
      return builder.performResolution(tasks, arch, deviceType).map(function(task) {
        if (!task.external && !task.resolved) {
          throw new Error(("Project type for service '" + task.serviceName + "' could not be determined. ") + 'Please add a Dockerfile');
        }
      });
    }).map(function(task) {
      var base, binPath, d, ref;
      d = imageDescriptorsByServiceName[task.serviceName];
      if (task.tag == null) {
        task.tag = [projectName, task.serviceName].join('_').toLowerCase();
      }
      if (d.image.context != null) {
        d.image.tag = task.tag;
      }
      if (task.dockerOpts == null) {
        task.dockerOpts = {};
      }
      _.merge(task.dockerOpts, buildOpts, {
        t: task.tag
      });
      if (((ref = d.image.context) != null ? ref.args : void 0) != null) {
        if ((base = task.dockerOpts).buildargs == null) {
          base.buildargs = {};
        }
        _.merge(task.dockerOpts.buildargs, d.image.context.args);
      }
      task.logStream = renderer.streams[task.serviceName];
      task.logBuffer = [];
      if (task.external || !needsQemu) {
        return [task, null];
      }
      binPath = qemu.qemuPathInContext(path.join(projectPath, task.context));
      return transpose.transposeTarStream(task.buildStream, {
        hostQemuPath: toPosixPath(binPath),
        containerQemuPath: "/tmp/" + qemu.QEMU_BIN_NAME
      }).then(function(stream) {
        return task.buildStream = stream;
      })["return"]([task, binPath]);
    });
  }).map(function(arg) {
    var qemuPath, task;
    task = arg[0], qemuPath = arg[1];
    return Promise.resolve(task).tap(function(task) {
      var captureStream;
      captureStream = buildLogCapture(task.external, task.logBuffer);
      if (task.external) {
        captureStream.pipe(task.logStream);
        return task.progressHook = pullProgressAdapter(captureStream);
      } else {
        return task.streamHook = function(stream) {
          var buildThroughStream, rawStream;
          stream = createLogStream(stream);
          if (qemuPath != null) {
            buildThroughStream = transpose.getBuildThroughStream({
              hostQemuPath: toPosixPath(qemuPath),
              containerQemuPath: "/tmp/" + qemu.QEMU_BIN_NAME
            });
            rawStream = stream.pipe(buildThroughStream);
          } else {
            rawStream = stream;
          }
          return rawStream.pipe(dropEmptyLinesStream()).pipe(captureStream).pipe(buildProgressAdapter(inlineLogs)).pipe(task.logStream);
        };
      }
    });
  }).then(function(tasks) {
    logger.logDebug('Prepared tasks; building...');
    return builder.performBuilds(tasks, docker).map(function(builtImage) {
      var d, endTime, image, ref, startTime, task;
      if (!builtImage.successful) {
        builtImage.error.serviceName = builtImage.serviceName;
        throw builtImage.error;
      }
      d = imageDescriptorsByServiceName[builtImage.serviceName];
      task = _.find(tasks, {
        serviceName: builtImage.serviceName
      });
      image = {
        serviceName: d.serviceName,
        name: (ref = d.image.tag) != null ? ref : d.image,
        logs: truncateString(task.logBuffer.join('\n'), LOG_LENGTH_MAX),
        props: {
          dockerfile: builtImage.dockerfile,
          projectType: builtImage.projectType
        }
      };
      if ((startTime = builtImage.startTime)) {
        image.props.startTime = new Date(startTime);
      }
      if ((endTime = builtImage.endTime)) {
        image.props.endTime = new Date(endTime);
      }
      return docker.getImage(image.name).inspect().get('Size').then(function(size) {
        return image.props.size = size;
      })["return"](image);
    }).tap(function(images) {
      var summary;
      summary = _(images).map(function(arg) {
        var props, serviceName;
        serviceName = arg.serviceName, props = arg.props;
        return [serviceName, "Image size: " + (humanize.filesize(props.size))];
      }).fromPairs().value();
      return renderer.end(summary);
    });
  })["finally"](renderer.end);
};

createRelease = function(apiEndpoint, auth, userId, appId, composition) {
  var _, client, crypto, releaseMod;
  _ = require('lodash');
  crypto = require('crypto');
  releaseMod = require('resin-release');
  client = releaseMod.createClient({
    apiEndpoint: apiEndpoint,
    auth: auth
  });
  return releaseMod.create({
    client: client,
    user: userId,
    application: appId,
    composition: composition,
    source: 'local',
    commit: crypto.pseudoRandomBytes(16).toString('hex').toLowerCase()
  }).then(function(arg) {
    var release, serviceImages;
    release = arg.release, serviceImages = arg.serviceImages;
    release = _.omit(release, ['created_at', 'belongs_to__application', 'is_created_by__user', '__metadata']);
    serviceImages = _.mapValues(serviceImages, function(serviceImage) {
      return _.omit(serviceImage, ['created_at', 'is_a_build_of__service', '__metadata']);
    });
    return {
      client: client,
      release: release,
      serviceImages: serviceImages
    };
  });
};

tagServiceImages = function(docker, images, serviceImages) {
  return Promise.map(images, function(d) {
    var _match, imageName, name, ref, ref1, registry, repo, serviceImage, tag;
    serviceImage = serviceImages[d.serviceName];
    imageName = serviceImage.is_stored_at__image_location;
    ref = /(.*?)\/(.*?)(?::([^\/]*))?$/.exec(imageName), _match = ref[0], registry = ref[1], repo = ref[2], tag = (ref1 = ref[3]) != null ? ref1 : 'latest';
    name = registry + "/" + repo;
    return docker.getImage(d.name).tag({
      repo: name,
      tag: tag,
      force: true
    }).then(function() {
      return docker.getImage(name + ":" + tag);
    }).then(function(localImage) {
      return {
        serviceName: d.serviceName,
        serviceImage: serviceImage,
        localImage: localImage,
        registry: registry,
        repo: repo,
        logs: d.logs,
        props: d.props
      };
    });
  });
};

authorizePush = function(tokenAuthEndpoint, registry, images) {
  var _, sdk;
  _ = require('lodash');
  sdk = require('balena-sdk').fromSharedOptions();
  if (!_.isArray(images)) {
    images = [images];
  }
  return sdk.request.send({
    baseUrl: tokenAuthEndpoint,
    url: '/auth/v1/token',
    qs: {
      service: registry,
      scope: images.map(function(repo) {
        return "repository:" + repo + ":pull,push";
      })
    }
  }).get('body').get('token').catchReturn({});
};

pushAndUpdateServiceImages = function(docker, token, images, afterEach) {
  var DockerProgress, chalk, opts, progress, renderer, reporters, tty;
  chalk = require('chalk');
  DockerProgress = require('docker-progress').DockerProgress;
  tty = require('./tty')(process.stdout);
  opts = {
    authconfig: {
      registrytoken: token
    }
  };
  progress = new DockerProgress({
    dockerToolbelt: docker
  });
  renderer = pushProgressRenderer(tty, chalk.blue('[Push]') + '    ');
  reporters = progress.aggregateProgress(images.length, renderer);
  return Promise.using(tty.cursorHidden(), function() {
    return Promise.map(images, function(arg, index) {
      var localImage, logs, props, serviceImage;
      serviceImage = arg.serviceImage, localImage = arg.localImage, props = arg.props, logs = arg.logs;
      return Promise.join(localImage.inspect().get('Size'), progress.push(localImage.name, reporters[index], opts)["finally"](renderer.end), function(size, digest) {
        serviceImage.image_size = size;
        serviceImage.content_hash = digest;
        serviceImage.build_log = logs;
        serviceImage.dockerfile = props.dockerfile;
        serviceImage.project_type = props.projectType;
        if (props.startTime) {
          serviceImage.start_timestamp = props.startTime;
        }
        if (props.endTime) {
          serviceImage.end_timestamp = props.endTime;
        }
        serviceImage.push_timestamp = new Date();
        return serviceImage.status = 'success';
      }).tapCatch(function(e) {
        serviceImage.error_message = '' + e;
        return serviceImage.status = 'failed';
      })["finally"](function() {
        return typeof afterEach === "function" ? afterEach(serviceImage, props) : void 0;
      });
    });
  });
};

exports.deployProject = function(docker, logger, composition, images, appId, userId, auth, apiEndpoint, skipLogUpload) {
  var _, chalk, prefix, releaseMod, runloop, spinner, tty;
  _ = require('lodash');
  chalk = require('chalk');
  releaseMod = require('resin-release');
  tty = require('./tty')(process.stdout);
  prefix = chalk.cyan('[Info]') + '    ';
  spinner = createSpinner();
  runloop = runSpinner(tty, spinner, prefix + "Creating release...");
  return createRelease(apiEndpoint, auth, userId, appId, composition)["finally"](runloop.end).then(function(arg) {
    var client, release, serviceImages;
    client = arg.client, release = arg.release, serviceImages = arg.serviceImages;
    logger.logDebug('Tagging images...');
    return tagServiceImages(docker, images, serviceImages).tap(function(images) {
      logger.logDebug('Authorizing push...');
      return authorizePush(apiEndpoint, images[0].registry, _.map(images, 'repo')).then(function(token) {
        logger.logInfo('Pushing images to registry...');
        return pushAndUpdateServiceImages(docker, token, images, function(serviceImage) {
          logger.logDebug("Saving image " + serviceImage.is_stored_at__image_location);
          if (skipLogUpload) {
            delete serviceImage.build_log;
          }
          return releaseMod.updateImage(client, serviceImage.id, serviceImage);
        });
      })["finally"](function() {
        logger.logDebug('Untagging images...');
        return Promise.map(images, function(arg1) {
          var localImage;
          localImage = arg1.localImage;
          return localImage.remove();
        });
      });
    }).then(function() {
      return release.status = 'success';
    }).tapCatch(function() {
      return release.status = 'failed';
    })["finally"](function() {
      runloop = runSpinner(tty, spinner, prefix + "Saving release...");
      release.end_timestamp = new Date();
      return releaseMod.updateRelease(client, release.id, release)["finally"](runloop.end);
    })["return"](release);
  });
};

renderProgressBar = function(percentage, stepCount) {
  var _, bar, barCount, spaceCount;
  _ = require('lodash');
  percentage = _.clamp(percentage, 0, 100);
  barCount = Math.floor(stepCount * percentage / 100);
  spaceCount = stepCount - barCount;
  bar = "[" + (_.repeat('=', barCount)) + ">" + (_.repeat(' ', spaceCount)) + "]";
  return bar + " " + (_.padStart(percentage, 3)) + "%";
};

pushProgressRenderer = function(tty, prefix) {
  var fn;
  fn = function(e) {
    var bar, error, percentage;
    error = e.error, percentage = e.percentage;
    if (error != null) {
      throw new Error(error);
    }
    bar = renderProgressBar(percentage, 40);
    return tty.replaceLine("" + prefix + bar + "\r");
  };
  fn.end = function() {
    return tty.clearLine();
  };
  return fn;
};

createLogStream = function(input) {
  var split, stripAnsi;
  split = require('split');
  stripAnsi = require('strip-ansi-stream');
  return input.pipe(stripAnsi()).pipe(split());
};

dropEmptyLinesStream = function() {
  var through;
  through = require('through2');
  return through(function(data, enc, cb) {
    var str;
    str = data.toString('utf-8');
    if (str.trim()) {
      this.push(str);
    }
    return cb();
  });
};

buildLogCapture = function(objectMode, buffer) {
  var through;
  through = require('through2');
  return through({
    objectMode: objectMode
  }, function(data, enc, cb) {
    if (data.error) {
      buffer.push("" + data.error);
    } else if (data.progress && data.status) {
      buffer.push(data.progress + "% " + data.status);
    } else if (data.status) {
      buffer.push("" + data.status);
    } else {
      buffer.push(data);
    }
    return cb(null, data);
  });
};

buildProgressAdapter = function(inline) {
  var numSteps, progress, ref, step, stepRegex, through;
  through = require('through2');
  stepRegex = /^\s*Step\s+(\d+)\/(\d+)\s*: (.+)$/;
  ref = [null, null, void 0], step = ref[0], numSteps = ref[1], progress = ref[2];
  return through({
    objectMode: true
  }, function(str, enc, cb) {
    var match;
    if (str == null) {
      return cb(null, str);
    }
    if (inline) {
      return cb(null, {
        status: str
      });
    }
    if (/^Successfully tagged /.test(str)) {
      progress = void 0;
    } else {
      if ((match = stepRegex.exec(str))) {
        step = match[1];
        if (numSteps == null) {
          numSteps = match[2];
        }
        str = match[3];
      }
      if (step != null) {
        str = "Step " + step + "/" + numSteps + ": " + str;
        progress = Math.floor(parseInt(step, 10) * 100 / (parseInt(numSteps, 10)));
      }
    }
    return cb(null, {
      status: str,
      progress: progress
    });
  });
};

pullProgressAdapter = function(outStream) {
  return function(arg) {
    var error, errorDetail, id, percentage, ref, status;
    status = arg.status, id = arg.id, percentage = arg.percentage, error = arg.error, errorDetail = arg.errorDetail;
    if (status != null) {
      status = status.replace(/^Status: /, '');
    }
    if (id != null) {
      status = id + ": " + status;
    }
    if (percentage === 100) {
      percentage = void 0;
    }
    return outStream.write({
      status: status,
      progress: percentage,
      error: (ref = errorDetail != null ? errorDetail.message : void 0) != null ? ref : error
    });
  };
};

createSpinner = function() {
  var chars, index;
  chars = '|/-\\';
  index = 0;
  return function() {
    return chars[(index++) % chars.length];
  };
};

runSpinner = function(tty, spinner, msg) {
  var runloop;
  runloop = createRunLoop(function() {
    tty.clearLine();
    tty.writeLine(msg + " " + (spinner()));
    return tty.cursorUp();
  });
  runloop.onEnd = function() {
    tty.clearLine();
    return tty.writeLine(msg);
  };
  return runloop;
};

createRunLoop = function(tick) {
  var runloop, timerId;
  timerId = setInterval(tick, 1000 / 10);
  runloop = {
    onEnd: function() {},
    end: function() {
      clearInterval(timerId);
      return runloop.onEnd();
    }
  };
  return runloop;
};

BuildProgressUI = (function() {
  function BuildProgressUI(tty, descriptors) {
    this._display = bind(this._display, this);
    this.end = bind(this.end, this);
    this.start = bind(this.start, this);
    this._handleInterrupt = bind(this._handleInterrupt, this);
    this._handleEvent = bind(this._handleEvent, this);
    var _, chalk, eventHandler, offset, prefix, services, streams, through;
    _ = require('lodash');
    chalk = require('chalk');
    through = require('through2');
    eventHandler = this._handleEvent;
    services = _.map(descriptors, 'serviceName');
    streams = _(services).map(function(service) {
      var stream;
      stream = through.obj(function(event, _enc, cb) {
        eventHandler(service, event);
        return cb();
      });
      stream.pipe(tty.stream);
      return [service, stream];
    }).fromPairs().value();
    this._tty = tty;
    this._serviceToDataMap = {};
    this._services = services;
    prefix = chalk.blue('[Build]') + '   ';
    offset = 10;
    this._prefixWidth = offset + prefix.length + _.max(_.map(services, 'length'));
    this._prefix = prefix;
    this._maxLineWidth = null;
    this._lineWidths = [];
    this._startTime = null;
    this._ended = false;
    this._cancelled = false;
    this._spinner = createSpinner();
    this.streams = streams;
  }

  BuildProgressUI.prototype._handleEvent = function(service, event) {
    return this._serviceToDataMap[service] = event;
  };

  BuildProgressUI.prototype._handleInterrupt = function() {
    this._cancelled = true;
    this.end();
    return process.exit(130);
  };

  BuildProgressUI.prototype.start = function() {
    process.on('SIGINT', this._handleInterrupt);
    this._tty.hideCursor();
    this._services.forEach((function(_this) {
      return function(service) {
        return _this.streams[service].write({
          status: 'Preparing...'
        });
      };
    })(this));
    this._runloop = createRunLoop(this._display);
    return this._startTime = Date.now();
  };

  BuildProgressUI.prototype.end = function(summary) {
    if (summary == null) {
      summary = null;
    }
    if (this._ended) {
      return;
    }
    this._ended = true;
    process.removeListener('SIGINT', this._handleInterrupt);
    this._runloop.end();
    this._runloop = null;
    this._clear();
    this._renderStatus(true);
    this._renderSummary(summary != null ? summary : this._getServiceSummary());
    return this._tty.showCursor();
  };

  BuildProgressUI.prototype._display = function() {
    this._clear();
    this._renderStatus();
    this._renderSummary(this._getServiceSummary());
    return this._tty.cursorUp(this._services.length + 1);
  };

  BuildProgressUI.prototype._clear = function() {
    this._tty.deleteToEnd();
    return this._maxLineWidth = this._tty.currentWindowSize().width;
  };

  BuildProgressUI.prototype._getServiceSummary = function() {
    var _, serviceToDataMap, services;
    _ = require('lodash');
    services = this._services;
    serviceToDataMap = this._serviceToDataMap;
    return _(services).map(function(service) {
      var bar, error, progress, ref, ref1, status;
      ref1 = (ref = serviceToDataMap[service]) != null ? ref : {}, status = ref1.status, progress = ref1.progress, error = ref1.error;
      if (error) {
        return "" + error;
      } else if (progress) {
        bar = renderProgressBar(progress, 20);
        if (status) {
          return bar + " " + status;
        }
        return "" + bar;
      } else if (status) {
        return "" + status;
      } else {
        return 'Waiting...';
      }
    }).map(function(data, index) {
      return [services[index], data];
    }).fromPairs().value();
  };

  BuildProgressUI.prototype._renderStatus = function(end) {
    var durationStr, moment, runTime, serviceCount, serviceStr;
    if (end == null) {
      end = false;
    }
    moment = require('moment');
    require('moment-duration-format')(moment);
    this._tty.clearLine();
    this._tty.write(this._prefix);
    if (end && this._cancelled) {
      return this._tty.writeLine('Build cancelled');
    } else if (end) {
      serviceCount = this._services.length;
      serviceStr = serviceCount === 1 ? '1 service' : serviceCount + " services";
      runTime = Date.now() - this._startTime;
      durationStr = moment.duration(Math.floor(runTime / 1000), 'seconds').format();
      return this._tty.writeLine("Built " + serviceStr + " in " + durationStr);
    } else {
      return this._tty.writeLine("Building services... " + (this._spinner()));
    }
  };

  BuildProgressUI.prototype._renderSummary = function(serviceToStrMap) {
    var _, chalk, strlen, truncate;
    _ = require('lodash');
    chalk = require('chalk');
    truncate = require('cli-truncate');
    strlen = require('string-width');
    return this._services.forEach((function(_this) {
      return function(service, index) {
        var str;
        str = _.padEnd(_this._prefix + chalk.bold(service), _this._prefixWidth);
        str += serviceToStrMap[service];
        if (_this._maxLineWidth != null) {
          str = truncate(str, _this._maxLineWidth);
        }
        _this._lineWidths[index] = strlen(str);
        _this._tty.clearLine();
        return _this._tty.writeLine(str);
      };
    })(this));
  };

  return BuildProgressUI;

})();

BuildProgressInline = (function() {
  function BuildProgressInline(outStream, descriptors) {
    this._renderEvent = bind(this._renderEvent, this);
    this.end = bind(this.end, this);
    this.start = bind(this.start, this);
    var _, eventHandler, offset, services, streams, through;
    _ = require('lodash');
    through = require('through2');
    services = _.map(descriptors, 'serviceName');
    eventHandler = this._renderEvent;
    streams = _(services).map(function(service) {
      var stream;
      stream = through.obj(function(event, _enc, cb) {
        eventHandler(service, event);
        return cb();
      });
      stream.pipe(outStream);
      return [service, stream];
    }).fromPairs().value();
    offset = 10;
    this._prefixWidth = offset + _.max(_.map(services, 'length'));
    this._outStream = outStream;
    this._services = services;
    this._startTime = null;
    this._ended = false;
    this.streams = streams;
  }

  BuildProgressInline.prototype.start = function() {
    this._outStream.write('Building services...\n');
    this._services.forEach((function(_this) {
      return function(service) {
        return _this.streams[service].write({
          status: 'Preparing...'
        });
      };
    })(this));
    return this._startTime = Date.now();
  };

  BuildProgressInline.prototype.end = function(summary) {
    var durationStr, moment, runTime, serviceCount, serviceStr;
    if (summary == null) {
      summary = null;
    }
    moment = require('moment');
    require('moment-duration-format')(moment);
    if (this._ended) {
      return;
    }
    this._ended = true;
    if (summary != null) {
      this._services.forEach((function(_this) {
        return function(service) {
          return _this._renderEvent(service, summary[service]);
        };
      })(this));
    }
    if (this._cancelled) {
      return this._outStream.write('Build cancelled\n');
    } else {
      serviceCount = this._services.length;
      serviceStr = serviceCount === 1 ? '1 service' : serviceCount + " services";
      runTime = Date.now() - this._startTime;
      durationStr = moment.duration(Math.floor(runTime / 1000), 'seconds').format();
      return this._outStream.write("Built " + serviceStr + " in " + durationStr + "\n");
    }
  };

  BuildProgressInline.prototype._renderEvent = function(service, event) {
    var _, chalk, prefix, str;
    _ = require('lodash');
    chalk = require('chalk');
    str = (function() {
      var error, status;
      status = event.status, error = event.error;
      if (error) {
        return "" + error;
      } else if (status) {
        return "" + status;
      } else {
        return 'Waiting...';
      }
    })();
    prefix = _.padEnd(chalk.bold(service), this._prefixWidth);
    this._outStream.write(prefix);
    this._outStream.write(str);
    return this._outStream.write('\n');
  };

  return BuildProgressInline;

})();
