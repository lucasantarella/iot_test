"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const common_tags_1 = require("common-tags");
const helpers_1 = require("./helpers");
const ssh_1 = require("./ssh");
const MIN_BALENAOS_VERSION = 'v2.14.0';
function join(logger, sdk, deviceHostnameOrIp, appName) {
    return __awaiter(this, void 0, void 0, function* () {
        logger.logDebug('Checking login...');
        const isLoggedIn = yield sdk.auth.isLoggedIn();
        if (!isLoggedIn) {
            logger.logInfo("Looks like you're not logged in yet!");
            logger.logInfo("Let's go through a quick wizard to get you started.\n");
            yield helpers_1.runCommand('login');
        }
        logger.logDebug('Determining device...');
        const deviceIp = yield getOrSelectLocalDevice(deviceHostnameOrIp);
        yield assertDeviceIsCompatible(deviceIp);
        logger.logDebug(`Using device: ${deviceIp}`);
        logger.logDebug('Determining device type...');
        const deviceType = yield getDeviceType(deviceIp);
        logger.logDebug(`Device type: ${deviceType}`);
        logger.logDebug('Determining application...');
        const app = yield getOrSelectApplication(sdk, deviceType, appName);
        logger.logDebug(`Using application: ${app.app_name} (${app.device_type})`);
        if (app.device_type != deviceType) {
            logger.logDebug(`Forcing device type to: ${deviceType}`);
            app.device_type = deviceType;
        }
        logger.logDebug('Determining device OS version...');
        const deviceOsVersion = yield getOsVersion(deviceIp);
        logger.logDebug(`Device OS version: ${deviceOsVersion}`);
        logger.logDebug('Generating application config...');
        const config = yield generateApplicationConfig(sdk, app, {
            version: deviceOsVersion,
        });
        logger.logDebug(`Using config: ${JSON.stringify(config, null, 2)}`);
        logger.logDebug('Configuring...');
        yield configure(deviceIp, config);
        logger.logDebug('All done.');
        const platformUrl = yield sdk.settings.get('balenaUrl');
        logger.logSuccess(`Device successfully joined ${platformUrl}!`);
    });
}
exports.join = join;
function leave(logger, _sdk, deviceHostnameOrIp) {
    return __awaiter(this, void 0, void 0, function* () {
        logger.logDebug('Determining device...');
        const deviceIp = yield getOrSelectLocalDevice(deviceHostnameOrIp);
        yield assertDeviceIsCompatible(deviceIp);
        logger.logDebug(`Using device: ${deviceIp}`);
        logger.logDebug('Deconfiguring...');
        yield deconfigure(deviceIp);
        logger.logDebug('All done.');
        logger.logSuccess('Device successfully left the platform.');
    });
}
exports.leave = leave;
function execCommand(deviceIp, cmd, msg) {
    return __awaiter(this, void 0, void 0, function* () {
        const through = yield Promise.resolve().then(() => require('through2'));
        const visuals = yield Promise.resolve().then(() => require('resin-cli-visuals'));
        const spinner = new visuals.Spinner(`[${deviceIp}] Connecting...`);
        const innerSpinner = spinner.spinner;
        const stream = through(function (data, _enc, cb) {
            innerSpinner.setSpinnerTitle(`%s [${deviceIp}] ${msg}`);
            cb(null, data);
        });
        spinner.start();
        yield ssh_1.exec(deviceIp, cmd, stream);
        spinner.stop();
    });
}
function configure(deviceIp, config) {
    return __awaiter(this, void 0, void 0, function* () {
        const json = JSON.stringify(config);
        const b64 = Buffer.from(json).toString('base64');
        const str = `"$(base64 -d <<< ${b64})"`;
        yield execCommand(deviceIp, `os-config join '${str}'`, 'Configuring...');
    });
}
function deconfigure(deviceIp) {
    return __awaiter(this, void 0, void 0, function* () {
        yield execCommand(deviceIp, 'os-config leave', 'Configuring...');
    });
}
function assertDeviceIsCompatible(deviceIp) {
    return __awaiter(this, void 0, void 0, function* () {
        const { exitWithExpectedError } = yield Promise.resolve().then(() => require('../utils/patterns'));
        try {
            yield ssh_1.execBuffered(deviceIp, 'os-config --version');
        }
        catch (err) {
            exitWithExpectedError(common_tags_1.stripIndent `
			Device "${deviceIp}" is incompatible and cannot join or leave an application.
			Please select or provision device with balenaOS newer than ${MIN_BALENAOS_VERSION}.`);
        }
    });
}
function getDeviceType(deviceIp) {
    return __awaiter(this, void 0, void 0, function* () {
        const output = yield ssh_1.execBuffered(deviceIp, 'cat /etc/os-release');
        const match = /^SLUG="([^"]+)"$/m.exec(output);
        if (!match) {
            throw new Error('Failed to determine device type');
        }
        return match[1];
    });
}
function getOsVersion(deviceIp) {
    return __awaiter(this, void 0, void 0, function* () {
        const output = yield ssh_1.execBuffered(deviceIp, 'cat /etc/os-release');
        const match = /^VERSION_ID="([^"]+)"$/m.exec(output);
        if (!match) {
            throw new Error('Failed to determine OS version ID');
        }
        return match[1];
    });
}
function getOrSelectLocalDevice(deviceIp) {
    return __awaiter(this, void 0, void 0, function* () {
        if (deviceIp) {
            return deviceIp;
        }
        const through = yield Promise.resolve().then(() => require('through2'));
        let ip = null;
        const stream = through(function (data, _enc, cb) {
            const match = /^==> Selected device: (.*)$/m.exec(data.toString());
            if (match) {
                ip = match[1];
                cb();
            }
            else {
                cb(null, data);
            }
        });
        stream.pipe(process.stderr);
        const { sudo } = yield Promise.resolve().then(() => require('../utils/helpers'));
        const command = process.argv.slice(0, 2).concat(['internal', 'scandevices']);
        yield sudo(command, {
            stderr: stream,
            msg: 'Scanning for local devices. If asked, please type your computer password.',
        });
        if (!ip) {
            throw new Error('No device selected');
        }
        return ip;
    });
}
function selectAppFromList(applications) {
    return __awaiter(this, void 0, void 0, function* () {
        const _ = yield Promise.resolve().then(() => require('lodash'));
        const { selectFromList } = yield Promise.resolve().then(() => require('../utils/patterns'));
        return selectFromList('Select application', _.map(applications, app => {
            return _.merge({ name: app.slug }, app);
        }));
    });
}
function getOrSelectApplication(sdk, deviceType, appName) {
    return __awaiter(this, void 0, void 0, function* () {
        const _ = yield Promise.resolve().then(() => require('lodash'));
        const form = yield Promise.resolve().then(() => require('resin-cli-form'));
        const allDeviceTypes = yield sdk.models.config.getDeviceTypes();
        const deviceTypeManifest = _.find(allDeviceTypes, { slug: deviceType });
        if (!deviceTypeManifest) {
            throw new Error(`"${deviceType}" is not a valid device type`);
        }
        const compatibleDeviceTypes = _(allDeviceTypes)
            .filter({ arch: deviceTypeManifest.arch })
            .map(type => type.slug)
            .value();
        if (!appName) {
            const options = {
                $filter: { device_type: { $in: compatibleDeviceTypes } },
            };
            const applications = yield sdk.models.application.getAll(options);
            if (applications.length === 0) {
                const shouldCreateApp = yield form.ask({
                    message: 'You have no applications this device can join.\n' +
                        'Would you like to create one now?',
                    type: 'confirm',
                    default: true,
                });
                if (shouldCreateApp) {
                    return createApplication(sdk, deviceType);
                }
                process.exit(1);
            }
            return selectAppFromList(applications);
        }
        const options = {};
        let name;
        const match = appName.split('/');
        if (match.length > 1) {
            options.$filter = { slug: appName.toLowerCase() };
            name = match[1];
        }
        else {
            options.$filter = { app_name: appName };
            name = appName;
        }
        const applications = yield sdk.models.application.getAll(options);
        if (applications.length === 0) {
            const shouldCreateApp = yield form.ask({
                message: `No application found with name "${appName}".\n` +
                    'Would you like to create it now?',
                type: 'confirm',
                default: true,
            });
            if (shouldCreateApp) {
                return createApplication(sdk, deviceType, name);
            }
            process.exit(1);
        }
        const validApplications = applications.filter(app => _.includes(compatibleDeviceTypes, app.device_type));
        if (validApplications.length === 0) {
            throw new Error('No application found with a matching device type');
        }
        if (validApplications.length === 1) {
            return validApplications[0];
        }
        return selectAppFromList(applications);
    });
}
function createApplication(sdk, deviceType, name) {
    return __awaiter(this, void 0, void 0, function* () {
        const form = yield Promise.resolve().then(() => require('resin-cli-form'));
        const validation = yield Promise.resolve().then(() => require('./validation'));
        const patterns = yield Promise.resolve().then(() => require('./patterns'));
        let username = yield sdk.auth.whoami();
        if (!username) {
            throw new sdk.errors.BalenaNotLoggedIn();
        }
        username = username.toLowerCase();
        const appName = yield new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
            while (true) {
                try {
                    const appName = yield form.ask({
                        message: 'Enter a name for your new application:',
                        type: 'input',
                        default: name,
                        validate: validation.validateApplicationName,
                    });
                    try {
                        yield sdk.models.application.get(appName, {
                            $filter: {
                                $or: [
                                    { slug: { $startswith: `${username}/` } },
                                    { $not: { slug: { $contains: '/' } } },
                                ],
                            },
                        });
                        patterns.printErrorMessage('You already have an application with that name; please choose another.');
                        continue;
                    }
                    catch (err) {
                        return resolve(appName);
                    }
                }
                catch (err) {
                    return reject(err);
                }
            }
        }));
        return sdk.models.application.create({
            name: appName,
            deviceType,
        });
    });
}
function generateApplicationConfig(sdk, app, options) {
    return __awaiter(this, void 0, void 0, function* () {
        const form = yield Promise.resolve().then(() => require('resin-cli-form'));
        const { generateApplicationConfig: configGen } = yield Promise.resolve().then(() => require('./config'));
        const manifest = yield sdk.models.device.getManifestBySlug(app.device_type);
        const opts = manifest.options && manifest.options.filter(opt => opt.name !== 'network');
        const values = Object.assign({}, (yield form.run(opts)), options);
        const config = yield configGen(app, values);
        if (config.connectivity === 'connman') {
            delete config.connectivity;
            delete config.files;
        }
        return config;
    });
}
//# sourceMappingURL=promote.js.map