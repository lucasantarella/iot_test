// Generated by CoffeeScript 1.12.7
var Promise, appendConnectionOptions, createClient, ensureDockerSeemsAccessible, generateConnectOpts, parseBuildArgs;

Promise = require('bluebird');

exports.appendConnectionOptions = appendConnectionOptions = function(opts) {
  return opts.concat([
    {
      signature: 'docker',
      parameter: 'docker',
      description: 'Path to a local docker socket',
      alias: 'P'
    }, {
      signature: 'dockerHost',
      parameter: 'dockerHost',
      description: 'The address of the host containing the docker daemon',
      alias: 'h'
    }, {
      signature: 'dockerPort',
      parameter: 'dockerPort',
      description: 'The port on which the host docker daemon is listening',
      alias: 'p'
    }, {
      signature: 'ca',
      parameter: 'ca',
      description: 'Docker host TLS certificate authority file'
    }, {
      signature: 'cert',
      parameter: 'cert',
      description: 'Docker host TLS certificate file'
    }, {
      signature: 'key',
      parameter: 'key',
      description: 'Docker host TLS key file'
    }
  ]);
};

exports.appendOptions = function(opts) {
  return appendConnectionOptions(opts).concat([
    {
      signature: 'tag',
      parameter: 'tag',
      description: 'The alias to the generated image',
      alias: 't'
    }, {
      signature: 'buildArg',
      parameter: 'arg',
      description: 'Set a build-time variable (eg. "-B \'ARG=value\'"). Can be specified multiple times.',
      alias: 'B'
    }, {
      signature: 'nocache',
      description: "Don't use docker layer caching when building",
      boolean: true
    }, {
      signature: 'squash',
      description: 'Squash newly built layers into a single new layer',
      boolean: true
    }
  ]);
};

generateConnectOpts = function(opts) {
  var _, buildDockerodeOpts, fs;
  buildDockerodeOpts = require('dockerode-options');
  fs = require('mz/fs');
  _ = require('lodash');
  return Promise["try"](function() {
    var certBodies, connectOpts;
    connectOpts = {};
    if ((opts.docker != null) && (opts.dockerHost == null)) {
      connectOpts.socketPath = opts.docker;
    } else if ((opts.dockerHost != null) && (opts.docker == null)) {
      connectOpts.host = opts.dockerHost;
      connectOpts.port = opts.dockerPort || 2376;
    } else if ((opts.docker != null) && (opts.dockerHost != null)) {
      throw new Error("Both a local docker socket and docker host have been provided. Don't know how to continue.");
    } else if (process.env.DOCKER_HOST) {
      connectOpts = buildDockerodeOpts(process.env.DOCKER_HOST);
    } else {
      connectOpts.socketPath = '/var/run/docker.sock';
    }
    if ((opts.ca != null) || (opts.cert != null) || (opts.key != null)) {
      if (!((opts.ca != null) && (opts.cert != null) && (opts.key != null))) {
        throw new Error('You must provide a CA, certificate and key in order to use TLS');
      }
      certBodies = {
        ca: fs.readFile(opts.ca, 'utf-8'),
        cert: fs.readFile(opts.cert, 'utf-8'),
        key: fs.readFile(opts.key, 'utf-8')
      };
      return Promise.props(certBodies).then(function(toMerge) {
        return _.merge(connectOpts, toMerge);
      });
    }
    return connectOpts;
  });
};

parseBuildArgs = function(args) {
  var _, buildArgs;
  _ = require('lodash');
  if (!_.isArray(args)) {
    args = [args];
  }
  buildArgs = {};
  args.forEach(function(arg) {
    var pair, ref;
    pair = /^([^\s]+?)=(.*)$/.exec(arg);
    if (pair != null) {
      return buildArgs[pair[1]] = (ref = pair[2]) != null ? ref : '';
    } else {
      throw new Error("Could not parse build argument: '" + arg + "'");
    }
  });
  return buildArgs;
};

exports.generateBuildOpts = function(options) {
  var opts;
  opts = {};
  if (options.tag != null) {
    opts.t = options.tag;
  }
  if (options.nocache != null) {
    opts.nocache = true;
  }
  if (options.squash != null) {
    opts.squash = true;
  }
  if (options.buildArg != null) {
    opts.buildargs = parseBuildArgs(options.buildArg);
  }
  return opts;
};

exports.getDocker = function(options) {
  return generateConnectOpts(options).then(createClient).tap(ensureDockerSeemsAccessible);
};

exports.createClient = createClient = (function() {
  var Docker;
  Docker = require('docker-toolbelt');
  Promise.promisifyAll(Docker.prototype, {
    filter: function(name) {
      return name === 'run';
    },
    multiArgs: true
  });
  Promise.promisifyAll(Docker.prototype);
  Promise.promisifyAll(new Docker({}).getImage().constructor.prototype);
  Promise.promisifyAll(new Docker({}).getContainer().constructor.prototype);
  return function(opts) {
    return new Docker(opts);
  };
})();

ensureDockerSeemsAccessible = function(docker) {
  var exitWithExpectedError;
  exitWithExpectedError = require('./patterns').exitWithExpectedError;
  return docker.ping()["catch"](function() {
    return exitWithExpectedError('Docker seems to be unavailable. Is it installed and running?');
  });
};
