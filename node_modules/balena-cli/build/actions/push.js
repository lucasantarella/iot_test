"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const common_tags_1 = require("common-tags");
const errors_1 = require("../utils/device/errors");
const IP_REGEX = new RegExp(/\b(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\b/);
var BuildTarget;
(function (BuildTarget) {
    BuildTarget[BuildTarget["Cloud"] = 0] = "Cloud";
    BuildTarget[BuildTarget["Device"] = 1] = "Device";
})(BuildTarget || (BuildTarget = {}));
function getBuildTarget(appOrDevice) {
    if (/^[a-zA-Z0-9_-]+$/.test(appOrDevice)) {
        return BuildTarget.Cloud;
    }
    if (IP_REGEX.test(appOrDevice)) {
        return BuildTarget.Device;
    }
    return null;
}
function getAppOwner(sdk, appName) {
    return __awaiter(this, void 0, void 0, function* () {
        const { exitWithExpectedError, selectFromList, } = yield Promise.resolve().then(() => require('../utils/patterns'));
        const _ = yield Promise.resolve().then(() => require('lodash'));
        const applications = yield sdk.models.application.getAll({
            $expand: {
                user: {
                    $select: ['username'],
                },
            },
            $filter: {
                $eq: [{ $tolower: { $: 'app_name' } }, appName.toLowerCase()],
            },
            $select: ['id'],
        });
        if (applications == null || applications.length === 0) {
            exitWithExpectedError(common_tags_1.stripIndent `
			No applications found with name: ${appName}.

			This could mean that the application does not exist, or you do
			not have the permissions required to access it.`);
        }
        if (applications.length === 1) {
            return _.get(applications, '[0].user[0].username');
        }
        const entries = _.map(applications, app => {
            const username = _.get(app, 'user[0].username');
            return {
                name: `${username}/${appName}`,
                extra: username,
            };
        });
        const selected = yield selectFromList(`${entries.length} applications found with that name, please select the application you would like to push to`, entries);
        return selected.extra;
    });
}
function parseRegistrySecrets(secretsFilename) {
    return __awaiter(this, void 0, void 0, function* () {
        const { fs } = yield require('mz');
        const { RegistrySecretValidator } = yield require('resin-multibuild');
        try {
            let isYaml = false;
            if (/.+\.ya?ml$/i.test(secretsFilename)) {
                isYaml = true;
            }
            else if (!/.+\.json$/i.test(secretsFilename)) {
                throw new Error('Filename must end with .json, .yml or .yaml');
            }
            const raw = (yield fs.readFile(secretsFilename)).toString();
            return new RegistrySecretValidator().validateRegistrySecrets(isYaml ? (yield require('js-yaml')).safeLoad(raw) : JSON.parse(raw));
        }
        catch (error) {
            error.message =
                `Error validating registry secrets file "${secretsFilename}":\n` +
                    error.message;
            throw error;
        }
    });
}
exports.push = {
    signature: 'push <applicationOrDevice>',
    description: 'Start a remote build on the balena cloud build servers or a local mode device',
    help: common_tags_1.stripIndent `
		This command can be used to start a build on the remote balena cloud builders,
		or a local mode balena device.

		When building on the balena cloud the given source directory will be sent to the
		balena builder, and the build will proceed. This can be used as a drop-in
		replacement for git push to deploy.

		When building on a local mode device, the given source directory will be built
		on the device, and the resulting containers will be run on the device. Logs will
		be streamed back from the device as part of the same invocation.

		The --registry-secrets option specifies a JSON or YAML file containing private
		Docker registry usernames and passwords to be used when pulling base images.
		Sample registry-secrets YAML file:

			'https://idx.docker.io/v1/':
				username: mike
				password: cze14
			'myregistry.com:25000':
				username: ann
				password: hunter2


		Examples:

			$ balena push myApp
			$ balena push myApp --source <source directory>
			$ balena push myApp -s <source directory>

			$ balena push 10.0.0.1
			$ balena push 10.0.0.1 --source <source directory>
			$ balena push 10.0.0.1 -s <source directory>
	`,
    permission: 'user',
    options: [
        {
            signature: 'source',
            alias: 's',
            description: 'The source that should be sent to the balena builder to be built (defaults to the current directory)',
            parameter: 'source',
        },
        {
            signature: 'emulated',
            alias: 'e',
            description: 'Force an emulated build to occur on the remote builder',
            boolean: true,
        },
        {
            signature: 'nocache',
            alias: 'c',
            description: "Don't use cache when building this project",
            boolean: true,
        },
        {
            signature: 'registry-secrets',
            alias: 'R',
            parameter: 'secrets.yml|.json',
            description: common_tags_1.stripIndent `
				Path to a local YAML or JSON file containing Docker registry passwords used to pull base images`,
        },
    ],
    action(params, options, done) {
        return __awaiter(this, void 0, void 0, function* () {
            const sdk = (yield Promise.resolve().then(() => require('balena-sdk'))).fromSharedOptions();
            const Bluebird = yield Promise.resolve().then(() => require('bluebird'));
            const remote = yield Promise.resolve().then(() => require('../utils/remote-build'));
            const deviceDeploy = yield Promise.resolve().then(() => require('../utils/device/deploy'));
            const { exitWithExpectedError } = yield Promise.resolve().then(() => require('../utils/patterns'));
            const appOrDevice = params.applicationOrDevice;
            if (appOrDevice == null) {
                exitWithExpectedError('You must specify an application or a device');
            }
            const source = options.source || '.';
            if (process.env.DEBUG) {
                console.log(`[debug] Using ${source} as build source`);
            }
            const registrySecrets = options['registry-secrets']
                ? yield parseRegistrySecrets(options['registry-secrets'])
                : {};
            const buildTarget = getBuildTarget(appOrDevice);
            switch (buildTarget) {
                case BuildTarget.Cloud:
                    const app = appOrDevice;
                    Bluebird.join(sdk.auth.getToken(), sdk.settings.get('balenaUrl'), getAppOwner(sdk, app), (token, baseUrl, owner) => {
                        const opts = {
                            emulated: options.emulated,
                            nocache: options.nocache,
                            registrySecrets,
                        };
                        const args = {
                            app,
                            owner,
                            source,
                            auth: token,
                            baseUrl,
                            sdk,
                            opts,
                        };
                        return remote.startRemoteBuild(args);
                    }).nodeify(done);
                    break;
                case BuildTarget.Device:
                    const device = appOrDevice;
                    Bluebird.resolve(deviceDeploy.deployToDevice({
                        source,
                        deviceHost: device,
                        registrySecrets,
                    }))
                        .catch(errors_1.BuildError, e => {
                        exitWithExpectedError(e.toString());
                    })
                        .nodeify(done);
                    break;
                default:
                    exitWithExpectedError(common_tags_1.stripIndent `
					Build target not recognised. Please provide either an application name or device address.

					The only supported device addresses currently are IP addresses.

					If you believe your build target should have been detected, and this is an error, please
					create an issue.`);
                    break;
            }
        });
    },
};
//# sourceMappingURL=push.js.map