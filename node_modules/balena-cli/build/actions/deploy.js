// Generated by CoffeeScript 1.12.7
var Promise, compose, deployProject, dockerUtils;

Promise = require('bluebird');

dockerUtils = require('../utils/docker');

compose = require('../utils/compose');


/*
Opts must be an object with the following keys:

	app: the application instance to deploy to
	image: the image to deploy; optional
	shouldPerformBuild
	shouldUploadLogs
	buildEmulated
	buildOpts: arguments to forward to docker build command
 */

deployProject = function(docker, logger, composeOpts, opts) {
  var _, doodles, sdk;
  _ = require('lodash');
  doodles = require('resin-doodles');
  sdk = require('balena-sdk').fromSharedOptions();
  return compose.loadProject(logger, composeOpts.projectPath, composeOpts.projectName, opts.image).then(function(project) {
    var ref, ref1;
    if (project.descriptors.length > 1 && !((ref = opts.app.application_type) != null ? (ref1 = ref[0]) != null ? ref1.supports_multicontainer : void 0 : void 0)) {
      throw new Error('Target application does not support multiple containers. Aborting!');
    }
    return Promise.map(project.descriptors, function(d) {
      var ref2;
      if (opts.shouldPerformBuild) {
        return d;
      }
      return docker.getImage((ref2 = d.image.tag) != null ? ref2 : d.image).inspect()["return"](d.serviceName).catchReturn();
    }).filter(function(d) {
      return !!d;
    }).then(function(servicesToSkip) {
      var compositionToBuild;
      compositionToBuild = _.cloneDeep(project.composition);
      compositionToBuild.services = _.omit(compositionToBuild.services, servicesToSkip);
      if (_.size(compositionToBuild.services) === 0) {
        logger.logInfo('Everything is up to date (use --build to force a rebuild)');
        return {};
      }
      return compose.buildProject(docker, logger, project.path, project.name, compositionToBuild, opts.app.arch, opts.app.device_type, opts.buildEmulated, opts.buildOpts, composeOpts.inlineLogs).then(function(builtImages) {
        return _.keyBy(builtImages, 'serviceName');
      });
    }).then(function(builtImages) {
      return project.descriptors.map(function(d) {
        var ref2, ref3;
        return (ref2 = builtImages[d.serviceName]) != null ? ref2 : {
          serviceName: d.serviceName,
          name: (ref3 = d.image.tag) != null ? ref3 : d.image,
          logs: 'Build skipped; image for service already exists.',
          props: {}
        };
      });
    }).then(function(images) {
      var chalk, legacyDeploy, msg, ref2, ref3;
      if ((ref2 = opts.app.application_type) != null ? (ref3 = ref2[0]) != null ? ref3.is_legacy : void 0 : void 0) {
        chalk = require('chalk');
        legacyDeploy = require('../utils/deploy-legacy');
        msg = chalk.yellow('Target application requires legacy deploy method.');
        logger.logWarn(msg);
        return Promise.join(docker, logger, sdk.auth.getToken(), sdk.auth.whoami(), sdk.settings.get('balenaUrl'), {
          appName: opts.app.app_name,
          imageName: images[0].name,
          buildLogs: images[0].logs,
          shouldUploadLogs: opts.shouldUploadLogs
        }, legacyDeploy).then(function(releaseId) {
          return sdk.models.release.get(releaseId, {
            $select: ['commit']
          });
        });
      }
      return Promise.join(sdk.auth.getUserId(), sdk.auth.getToken(), sdk.settings.get('apiUrl'), function(userId, auth, apiEndpoint) {
        return compose.deployProject(docker, logger, project.composition, images, opts.app.id, userId, "Bearer " + auth, apiEndpoint, !opts.shouldUploadLogs);
      });
    });
  }).then(function(release) {
    logger.logSuccess('Deploy succeeded!');
    logger.logSuccess("Release: " + release.commit);
    console.log();
    console.log(doodles.getDoodle());
    return console.log();
  }).tapCatch(function(e) {
    return logger.logError('Deploy failed');
  });
};

module.exports = {
  signature: 'deploy <appName> [image]',
  description: 'Deploy a single image or a multicontainer project to a balena application',
  help: 'Use this command to deploy an image or a complete multicontainer project\nto an application, optionally building it first.\n\nUsage: `deploy <appName> ([image] | --build [--source build-dir])`\n\nUnless an image is specified, this command will look into the current directory\n(or the one specified by --source) for a compose file. If one is found, this\ncommand will deploy each service defined in the compose file, building it first\nif an image for it doesn\'t exist. If a compose file isn\'t found, the command\nwill look for a Dockerfile, and if yet that isn\'t found, it will try to\ngenerate one.\n\nTo deploy to an app on which you\'re a collaborator, use\n`balena deploy <appOwnerUsername>/<appName>`.\n\nNote: If building with this command, all options supported by `balena build`\nare also supported with this command.\n\nExamples:\n\n	$ balena deploy myApp\n	$ balena deploy myApp --build --source myBuildDir/\n	$ balena deploy myApp myApp/myImage',
  permission: 'user',
  primary: true,
  options: dockerUtils.appendOptions(compose.appendOptions([
    {
      signature: 'source',
      parameter: 'source',
      description: 'Specify an alternate source directory; default is the working directory',
      alias: 's'
    }, {
      signature: 'build',
      boolean: true,
      description: 'Force a rebuild before deploy',
      alias: 'b'
    }, {
      signature: 'nologupload',
      description: "Don't upload build logs to the dashboard with image (if building)",
      boolean: true
    }
  ])),
  action: function(params, options, done) {
    var Logger, helpers, logger;
    require('events').defaultMaxListeners = 1000;
    helpers = require('../utils/helpers');
    Logger = require('../utils/logger');
    logger = new Logger();
    logger.logDebug('Parsing input...');
    return Promise["try"](function() {
      var appName, image;
      appName = params.appName, image = params.image;
      if (appName == null) {
        appName = options.application;
      }
      delete options.application;
      if (appName == null) {
        throw new Error('Please specify the name of the application to deploy');
      }
      if ((image != null) && options.build) {
        throw new Error('Build option is not applicable when specifying an image');
      }
      return Promise.join(helpers.getApplication(appName), helpers.getArchAndDeviceType(appName), function(app, arg) {
        var arch, device_type;
        arch = arg.arch, device_type = arg.device_type;
        app.arch = arch;
        app.device_type = device_type;
        return app;
      }).then(function(app) {
        return [app, image, !!options.build, !options.nologupload];
      });
    }).then(function(arg) {
      var app, image, shouldPerformBuild, shouldUploadLogs;
      app = arg[0], image = arg[1], shouldPerformBuild = arg[2], shouldUploadLogs = arg[3];
      return Promise.join(dockerUtils.getDocker(options), dockerUtils.generateBuildOpts(options), compose.generateOpts(options), function(docker, buildOpts, composeOpts) {
        return deployProject(docker, logger, composeOpts, {
          app: app,
          image: image,
          shouldPerformBuild: shouldPerformBuild,
          shouldUploadLogs: shouldUploadLogs,
          buildEmulated: !!options.emulated,
          buildOpts: buildOpts
        });
      });
    }).asCallback(done);
  }
};
