// Generated by CoffeeScript 1.12.7

/*
Copyright 2016-2017 Balena

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
 */
var LATEST, allDeviceTypes, dockerUtils, getApplicationsWithSuccessfulBuilds, getDeviceTypes, getDeviceTypesWithSameArch, offerToDisableAutomaticUpdates, selectApplication, selectApplicationCommit;

dockerUtils = require('../utils/docker');

LATEST = 'latest';

allDeviceTypes = void 0;

getDeviceTypes = function() {
  var Bluebird, _, balena;
  Bluebird = require('bluebird');
  _ = require('lodash');
  if (allDeviceTypes !== void 0) {
    return Bluebird.resolve(allDeviceTypes);
  }
  balena = require('balena-sdk').fromSharedOptions();
  return balena.models.config.getDeviceTypes().then(function(deviceTypes) {
    return _.sortBy(deviceTypes, 'name');
  }).tap(function(dt) {
    return allDeviceTypes = dt;
  });
};

getDeviceTypesWithSameArch = function(deviceTypeSlug) {
  var _;
  _ = require('lodash');
  return getDeviceTypes().then(function(deviceTypes) {
    var deviceType;
    deviceType = _.find(deviceTypes, {
      slug: deviceTypeSlug
    });
    return _(deviceTypes).filter({
      arch: deviceType.arch
    }).map('slug').value();
  });
};

getApplicationsWithSuccessfulBuilds = function(deviceType) {
  var balena, preload;
  preload = require('balena-preload');
  balena = require('balena-sdk').fromSharedOptions();
  return getDeviceTypesWithSameArch(deviceType).then(function(deviceTypes) {
    return balena.pine.get({
      resource: 'my_application',
      options: {
        $filter: {
          device_type: {
            $in: deviceTypes
          },
          owns__release: {
            $any: {
              $alias: 'r',
              $expr: {
                r: {
                  status: 'success'
                }
              }
            }
          }
        },
        $expand: preload.applicationExpandOptions,
        $select: ['id', 'app_name', 'device_type', 'commit', 'should_track_latest_release'],
        $orderby: 'app_name asc'
      }
    });
  });
};

selectApplication = function(deviceType) {
  var applicationInfoSpinner, exitWithExpectedError, form, visuals;
  visuals = require('resin-cli-visuals');
  form = require('resin-cli-form');
  exitWithExpectedError = require('../utils/patterns').exitWithExpectedError;
  applicationInfoSpinner = new visuals.Spinner('Downloading list of applications and releases.');
  applicationInfoSpinner.start();
  return getApplicationsWithSuccessfulBuilds(deviceType).then(function(applications) {
    applicationInfoSpinner.stop();
    if (applications.length === 0) {
      exitWithExpectedError("You have no apps with successful releases for a '" + deviceType + "' device type.");
    }
    return form.ask({
      message: 'Select an application',
      type: 'list',
      choices: applications.map(function(app) {
        return {
          name: app.app_name,
          value: app
        };
      })
    });
  });
};

selectApplicationCommit = function(releases) {
  var DEFAULT_CHOICE, choices, exitWithExpectedError, form;
  form = require('resin-cli-form');
  exitWithExpectedError = require('../utils/patterns').exitWithExpectedError;
  if (releases.length === 0) {
    exitWithExpectedError('This application has no successful releases.');
  }
  DEFAULT_CHOICE = {
    'name': LATEST,
    'value': LATEST
  };
  choices = [DEFAULT_CHOICE].concat(releases.map(function(release) {
    return {
      name: release.end_timestamp + " - " + release.commit,
      value: release.commit
    };
  }));
  return form.ask({
    message: 'Select a release',
    type: 'list',
    "default": LATEST,
    choices: choices
  });
};

offerToDisableAutomaticUpdates = function(application, commit) {
  var Promise, balena, form, message;
  Promise = require('bluebird');
  balena = require('balena-sdk').fromSharedOptions();
  form = require('resin-cli-form');
  if (commit === LATEST || !application.should_track_latest_release) {
    return Promise.resolve();
  }
  message = '\nThis application is set to automatically update all devices to the latest available version.\nThis might be unexpected behaviour: with this enabled, the preloaded device will still\ndownload and install the latest release once it is online.\n\nDo you want to disable automatic updates for this application?\n\nWarning: To re-enable this requires direct api calls,\nsee https://balena.io/docs/reference/api/resources/device/#set-device-to-release';
  return form.ask({
    message: message,
    type: 'confirm'
  }).then(function(update) {
    if (!update) {
      return;
    }
    return balena.pine.patch({
      resource: 'application',
      id: application.id,
      body: {
        should_track_latest_release: false
      }
    });
  });
};

module.exports = {
  signature: 'preload <image>',
  description: '(beta) preload an app on a disk image (or Edison zip archive)',
  help: 'Warning: "balena preload" requires Docker to be correctly installed in\nyour shell environment. For more information (including Windows support)\nplease check the README here: https://github.com/balena-io/balena-cli .\n\nUse this command to preload an application to a local disk image (or\nEdison zip archive) with a built release from balena.\n\nExamples:\n\n	$ balena preload balena.img --app 1234 --commit e1f2592fc6ee949e68756d4f4a48e49bff8d72a0 --splash-image image.png\n	$ balena preload balena.img',
  permission: 'user',
  primary: true,
  options: dockerUtils.appendConnectionOptions([
    {
      signature: 'app',
      parameter: 'appId',
      description: 'id of the application to preload',
      alias: 'a'
    }, {
      signature: 'commit',
      parameter: 'hash',
      description: 'the commit hash for a specific application release to preload, use "latest" to specify the latest release\n(ignored if no appId is given)',
      alias: 'c'
    }, {
      signature: 'splash-image',
      parameter: 'splashImage.png',
      description: 'path to a png image to replace the splash screen',
      alias: 's'
    }, {
      signature: 'dont-check-arch',
      boolean: true,
      description: 'Disables check for matching architecture in image and application'
    }, {
      signature: 'pin-device-to-release',
      boolean: true,
      description: 'Pin the preloaded device to the preloaded release on provision',
      alias: 'p'
    }
  ]),
  action: function(params, options, done) {
    var Promise, _, balena, exitWithExpectedError, nodeCleanup, preload, progressBars, progressHandler, spinnerHandler, spinners, visuals;
    _ = require('lodash');
    Promise = require('bluebird');
    balena = require('balena-sdk').fromSharedOptions();
    preload = require('balena-preload');
    visuals = require('resin-cli-visuals');
    nodeCleanup = require('node-cleanup');
    exitWithExpectedError = require('../utils/patterns').exitWithExpectedError;
    progressBars = {};
    progressHandler = function(event) {
      var progressBar;
      progressBar = progressBars[event.name];
      if (!progressBar) {
        progressBar = progressBars[event.name] = new visuals.Progress(event.name);
      }
      return progressBar.update({
        percentage: event.percentage
      });
    };
    spinners = {};
    spinnerHandler = function(event) {
      var spinner;
      spinner = spinners[event.name];
      if (!spinner) {
        spinner = spinners[event.name] = new visuals.Spinner(event.name);
      }
      if (event.action === 'start') {
        return spinner.start();
      } else {
        console.log();
        return spinner.stop();
      }
    };
    options.image = params.image;
    options.appId = options.app;
    delete options.app;
    options.splashImage = options['splash-image'];
    delete options['splash-image'];
    options.dontCheckArch = options['dont-check-arch'] || false;
    delete options['dont-check-arch'];
    if (options.dontCheckArch && !options.appId) {
      exitWithExpectedError('You need to specify an app id if you disable the architecture check.');
    }
    options.pinDevice = options['pin-device-to-release'] || false;
    delete options['pin-device-to-release'];
    return dockerUtils.getDocker(options).then(function(docker) {
      var gotSignal, preloader;
      preloader = new preload.Preloader(balena, docker, options.appId, options.commit, options.image, options.splashImage, options.proxy, options.dontCheckArch, options.pinDevice);
      gotSignal = false;
      nodeCleanup(function(exitCode, signal) {
        if (signal) {
          gotSignal = true;
          nodeCleanup.uninstall();
          preloader.cleanup().then(function() {
            return process.kill(process.pid, signal);
          });
          return false;
        }
      });
      if (process.env.DEBUG) {
        preloader.stderr.pipe(process.stderr);
      }
      preloader.on('progress', progressHandler);
      preloader.on('spinner', spinnerHandler);
      return new Promise(function(resolve, reject) {
        preloader.on('error', reject);
        return preloader.prepare().then(function() {
          return Promise["try"](function() {
            if (!preloader.appId) {
              return selectApplication(preloader.config.deviceType).then(function(application) {
                return preloader.setApplication(application);
              });
            }
          });
        }).then(function() {
          return Promise["try"](function() {
            var release;
            if (options.commit) {
              if (options.commit === LATEST && preloader.application.commit) {
                return LATEST;
              }
              release = _.find(preloader.application.owns__release, function(release) {
                return release.commit.startsWith(options.commit);
              });
              if (!release) {
                exitWithExpectedError('There is no release matching this commit');
              }
              return release.commit;
            }
            return selectApplicationCommit(preloader.application.owns__release);
          }).then(function(commit) {
            if (commit === LATEST) {
              preloader.commit = preloader.application.commit;
            } else {
              preloader.commit = commit;
            }
            return offerToDisableAutomaticUpdates(preloader.application, commit);
          });
        }).then(function() {
          return preloader.preload();
        })["catch"](balena.errors.BalenaError, exitWithExpectedError).then(resolve)["catch"](reject);
      }).then(done)["finally"](function() {
        if (!gotSignal) {
          return preloader.cleanup();
        }
      });
    });
  }
};
